
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.19+36 (git sha1 30a4218f5, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Running command `verilog_defines  -DNO_ICE40_DEFAULT_ASSIGNMENTS ; read_verilog -Irtl -sv rtl/adder.sv rtl/alu.sv rtl/arm.sv rtl/condlogic.sv rtl/controller.sv rtl/cpu_main.sv rtl/datapath.sv rtl/decoder.sv rtl/dmem.sv rtl/extend.sv rtl/flopenr.sv rtl/flopr.sv rtl/imem.sv rtl/mux2.sv rtl/regfile.sv ; synth_ice40 -device u -abc9 -noflatten' --

1. Executing Verilog-2005 frontend: rtl/adder.sv
Parsing SystemVerilog input from `rtl/adder.sv' to AST representation.
Generating RTLIL representation for module `\adder'.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend: rtl/alu.sv
Parsing SystemVerilog input from `rtl/alu.sv' to AST representation.
Generating RTLIL representation for module `\alu'.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend: rtl/arm.sv
Parsing SystemVerilog input from `rtl/arm.sv' to AST representation.
Generating RTLIL representation for module `\arm'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend: rtl/condlogic.sv
Parsing SystemVerilog input from `rtl/condlogic.sv' to AST representation.
Generating RTLIL representation for module `\condlogic'.
Generating RTLIL representation for module `\condcheck'.
Successfully finished Verilog frontend.

5. Executing Verilog-2005 frontend: rtl/controller.sv
Parsing SystemVerilog input from `rtl/controller.sv' to AST representation.
Generating RTLIL representation for module `\controller'.
Successfully finished Verilog frontend.

6. Executing Verilog-2005 frontend: rtl/cpu_main.sv
Parsing SystemVerilog input from `rtl/cpu_main.sv' to AST representation.
Generating RTLIL representation for module `\cpu_main'.
Successfully finished Verilog frontend.

7. Executing Verilog-2005 frontend: rtl/datapath.sv
Parsing SystemVerilog input from `rtl/datapath.sv' to AST representation.
Generating RTLIL representation for module `\datapath'.
Successfully finished Verilog frontend.

8. Executing Verilog-2005 frontend: rtl/decoder.sv
Parsing SystemVerilog input from `rtl/decoder.sv' to AST representation.
Generating RTLIL representation for module `\decoder'.
Successfully finished Verilog frontend.

9. Executing Verilog-2005 frontend: rtl/dmem.sv
Parsing SystemVerilog input from `rtl/dmem.sv' to AST representation.
Generating RTLIL representation for module `\dmem'.
Successfully finished Verilog frontend.

10. Executing Verilog-2005 frontend: rtl/extend.sv
Parsing SystemVerilog input from `rtl/extend.sv' to AST representation.
Generating RTLIL representation for module `\extend'.
Successfully finished Verilog frontend.

11. Executing Verilog-2005 frontend: rtl/flopenr.sv
Parsing SystemVerilog input from `rtl/flopenr.sv' to AST representation.
Generating RTLIL representation for module `\flopenr'.
Successfully finished Verilog frontend.

12. Executing Verilog-2005 frontend: rtl/flopr.sv
Parsing SystemVerilog input from `rtl/flopr.sv' to AST representation.
Generating RTLIL representation for module `\flopr'.
Successfully finished Verilog frontend.

13. Executing Verilog-2005 frontend: rtl/imem.sv
Parsing SystemVerilog input from `rtl/imem.sv' to AST representation.
Generating RTLIL representation for module `\imem'.
Successfully finished Verilog frontend.

14. Executing Verilog-2005 frontend: rtl/mux2.sv
Parsing SystemVerilog input from `rtl/mux2.sv' to AST representation.
Generating RTLIL representation for module `\mux2'.
Successfully finished Verilog frontend.

15. Executing Verilog-2005 frontend: rtl/regfile.sv
Parsing SystemVerilog input from `rtl/regfile.sv' to AST representation.
Generating RTLIL representation for module `\regfile'.
Successfully finished Verilog frontend.

16. Executing SYNTH_ICE40 pass.

16.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Generating RTLIL representation for module `\ICESTORM_RAM'.
Successfully finished Verilog frontend.

16.2. Executing HIERARCHY pass (managing design hierarchy).

16.2.1. Finding top of design hierarchy..
root of   0 design levels: regfile             
root of   0 design levels: mux2                
root of   0 design levels: imem                
root of   0 design levels: flopr               
root of   0 design levels: flopenr             
root of   0 design levels: extend              
root of   0 design levels: dmem                
root of   0 design levels: decoder             
root of   1 design levels: datapath            
root of   4 design levels: cpu_main            
root of   2 design levels: controller          
root of   0 design levels: condcheck           
root of   1 design levels: condlogic           
root of   3 design levels: arm                 
root of   0 design levels: alu                 
root of   0 design levels: adder               
Automatically selected cpu_main as design top module.

16.2.2. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             \mux2
Used module:             \extend
Used module:             \regfile
Used module:             \adder
Used module:             \flopr
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 \flopenr
Used module:             \decoder
Parameter 1 (\WIDTH) = 32

16.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\mux2'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 4

16.2.4. Executing AST frontend in derive mode using pre-parsed AST for module `\mux2'.
Parameter 1 (\WIDTH) = 4
Generating RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Parameter 1 (\WIDTH) = 4
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Parameter 1 (\WIDTH) = 32

16.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\adder'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32

16.2.6. Executing AST frontend in derive mode using pre-parsed AST for module `\flopr'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 2

16.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\flopenr'.
Parameter 1 (\WIDTH) = 2
Generating RTLIL representation for module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Parameter 1 (\WIDTH) = 2
Found cached RTLIL representation for module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.

16.2.8. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             \extend
Used module:             \regfile
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder

16.2.9. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             \extend
Used module:             \regfile
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Removing unused module `\mux2'.
Removing unused module `\flopr'.
Removing unused module `\flopenr'.
Removing unused module `\adder'.
Removed 4 unused modules.
Mapping positional arguments of cell datapath.alu (alu).
Mapping positional arguments of cell datapath.srcbmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.ext (extend).
Mapping positional arguments of cell datapath.resmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.rf (regfile).
Mapping positional arguments of cell datapath.ra2mux ($paramod\mux2\WIDTH=s32'00000000000000000000000000000100).
Mapping positional arguments of cell datapath.ra1mux ($paramod\mux2\WIDTH=s32'00000000000000000000000000000100).
Mapping positional arguments of cell datapath.pcadd2 ($paramod\adder\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcadd1 ($paramod\adder\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcreg ($paramod\flopr\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell cpu_main.dmem (dmem).
Mapping positional arguments of cell cpu_main.imem (imem).
Mapping positional arguments of cell cpu_main.arm (arm).
Mapping positional arguments of cell controller.cl (condlogic).
Mapping positional arguments of cell controller.dec (decoder).
Mapping positional arguments of cell condlogic.cc (condcheck).
Mapping positional arguments of cell condlogic.flagreg0 ($paramod\flopenr\WIDTH=s32'00000000000000000000000000000010).
Mapping positional arguments of cell condlogic.flagreg1 ($paramod\flopenr\WIDTH=s32'00000000000000000000000000000010).
Mapping positional arguments of cell arm.dp (datapath).
Mapping positional arguments of cell arm.c (controller).

16.3. Executing PROC pass (convert processes to netlists).

16.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392 in module SB_DFFNES.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$387 in module SB_DFFNESS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383 in module SB_DFFNER.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$378 in module SB_DFFNESR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$375 in module SB_DFFNS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$372 in module SB_DFFNSS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$369 in module SB_DFFNR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$366 in module SB_DFFNSR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358 in module SB_DFFES.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$353 in module SB_DFFESS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349 in module SB_DFFER.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$344 in module SB_DFFESR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$341 in module SB_DFFS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$338 in module SB_DFFSS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$335 in module SB_DFFR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$332 in module SB_DFFSR.
Marked 1 switch rules as full_case in process $proc$rtl/regfile.sv:15$140 in module regfile.
Marked 1 switch rules as full_case in process $proc$rtl/flopenr.sv:6$536 in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Marked 1 switch rules as full_case in process $proc$rtl/flopr.sv:5$535 in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Marked 1 switch rules as full_case in process $proc$rtl/extend.sv:0$61 in module extend.
Marked 1 switch rules as full_case in process $proc$rtl/dmem.sv:30$53 in module dmem.
Marked 2 switch rules as full_case in process $proc$rtl/decoder.sv:0$42 in module decoder.
Marked 3 switch rules as full_case in process $proc$rtl/decoder.sv:0$41 in module decoder.
Marked 1 switch rules as full_case in process $proc$rtl/condlogic.sv:0$25 in module condcheck.
Removed 1 dead cases from process $proc$rtl/alu.sv:0$15 in module alu.
Marked 1 switch rules as full_case in process $proc$rtl/alu.sv:0$15 in module alu.
Removed a total of 1 dead cases.

16.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 9 redundant assignments.
Promoted 59 assignments to connections.

16.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$395'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$391'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$386'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$382'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$377'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$374'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$371'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$368'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$365'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$363'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$361'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$357'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$352'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$348'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$331'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$329'.
  Set init value: \Q = 1'0

16.3.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \S in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392'.
Found async reset \R in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383'.
Found async reset \S in `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$375'.
Found async reset \R in `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$369'.
Found async reset \S in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358'.
Found async reset \R in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349'.
Found async reset \S in `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$341'.
Found async reset \R in `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$335'.
Found async reset \reset in `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$536'.
Found async reset \reset in `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$535'.

16.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~29 debug messages>

16.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$395'.
Creating decoders for process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$391'.
Creating decoders for process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$387'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$386'.
Creating decoders for process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$382'.
Creating decoders for process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$378'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$377'.
Creating decoders for process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$375'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$374'.
Creating decoders for process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$372'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$371'.
Creating decoders for process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$369'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$368'.
Creating decoders for process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$366'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$365'.
Creating decoders for process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$364'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$363'.
Creating decoders for process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$362'.
Creating decoders for process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$361'.
Creating decoders for process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$357'.
Creating decoders for process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$353'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$352'.
Creating decoders for process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$348'.
Creating decoders for process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$344'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
Creating decoders for process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$341'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
Creating decoders for process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$338'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
Creating decoders for process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$335'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
Creating decoders for process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$332'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$331'.
Creating decoders for process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$330'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$329'.
Creating decoders for process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$328'.
Creating decoders for process `\regfile.$proc$rtl/regfile.sv:15$140'.
     1/3: $1$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$146
     2/3: $1$memwr$\rf$rtl/regfile.sv:16$139_DATA[31:0]$145
     3/3: $1$memwr$\rf$rtl/regfile.sv:16$139_ADDR[3:0]$144
Creating decoders for process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$536'.
     1/1: $0\q[1:0]
Creating decoders for process `\imem.$proc$rtl/imem.sv:0$113'.
Creating decoders for process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$535'.
     1/1: $0\q[31:0]
Creating decoders for process `\extend.$proc$rtl/extend.sv:0$61'.
     1/1: $1\ExtImm[31:0]
Creating decoders for process `\dmem.$proc$rtl/dmem.sv:30$53'.
     1/3: $1$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$59
     2/3: $1$memwr$\RAM$rtl/dmem.sv:33$52_DATA[7:0]$58
     3/3: $1$memwr$\RAM$rtl/dmem.sv:33$52_ADDR[7:0]$57
Creating decoders for process `\decoder.$proc$rtl/decoder.sv:0$42'.
     1/4: $1\FlagW[1:0] [1]
     2/4: $2\ALUControl[1:0]
     3/4: $1\FlagW[1:0] [0]
     4/4: $1\ALUControl[1:0]
Creating decoders for process `\decoder.$proc$rtl/decoder.sv:0$41'.
     1/3: $3\controls[9:0]
     2/3: $2\controls[9:0]
     3/3: $1\controls[9:0]
Creating decoders for process `\condcheck.$proc$rtl/condlogic.sv:0$25'.
     1/1: $1\CondEx[0:0]
Creating decoders for process `\alu.$proc$rtl/alu.sv:0$15'.
     1/1: $1\ALUResult[31:0]

16.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:40$64_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:41$65_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:42$66_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:43$67_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:44$68_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:45$69_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:46$70_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:47$71_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:48$72_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:49$73_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:50$74_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:51$75_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:52$76_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:54$77_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:55$78_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:56$79_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:57$80_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:58$81_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:59$82_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:60$83_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:61$84_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:62$85_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:63$86_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:64$87_EN' from process `\imem.$proc$rtl/imem.sv:0$113'.
No latch inferred for signal `\extend.\ExtImm' from process `\extend.$proc$rtl/extend.sv:0$61'.
No latch inferred for signal `\decoder.\ALUControl' from process `\decoder.$proc$rtl/decoder.sv:0$42'.
No latch inferred for signal `\decoder.\FlagW' from process `\decoder.$proc$rtl/decoder.sv:0$42'.
No latch inferred for signal `\decoder.\controls' from process `\decoder.$proc$rtl/decoder.sv:0$41'.
No latch inferred for signal `\condcheck.\CondEx' from process `\condcheck.$proc$rtl/condlogic.sv:0$25'.
No latch inferred for signal `\alu.\ALUResult' from process `\alu.$proc$rtl/alu.sv:0$15'.

16.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\SB_DFFNES.\Q' using process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392'.
  created $adff cell `$procdff$666' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESS.\Q' using process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$387'.
  created $dff cell `$procdff$667' with negative edge clock.
Creating register for signal `\SB_DFFNER.\Q' using process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383'.
  created $adff cell `$procdff$668' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESR.\Q' using process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$378'.
  created $dff cell `$procdff$669' with negative edge clock.
Creating register for signal `\SB_DFFNS.\Q' using process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$375'.
  created $adff cell `$procdff$670' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSS.\Q' using process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$372'.
  created $dff cell `$procdff$671' with negative edge clock.
Creating register for signal `\SB_DFFNR.\Q' using process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$369'.
  created $adff cell `$procdff$672' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSR.\Q' using process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$366'.
  created $dff cell `$procdff$673' with negative edge clock.
Creating register for signal `\SB_DFFNE.\Q' using process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$364'.
  created $dff cell `$procdff$674' with negative edge clock.
Creating register for signal `\SB_DFFN.\Q' using process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$362'.
  created $dff cell `$procdff$675' with negative edge clock.
Creating register for signal `\SB_DFFES.\Q' using process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358'.
  created $adff cell `$procdff$676' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESS.\Q' using process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$353'.
  created $dff cell `$procdff$677' with positive edge clock.
Creating register for signal `\SB_DFFER.\Q' using process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349'.
  created $adff cell `$procdff$678' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESR.\Q' using process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$344'.
  created $dff cell `$procdff$679' with positive edge clock.
Creating register for signal `\SB_DFFS.\Q' using process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$341'.
  created $adff cell `$procdff$680' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSS.\Q' using process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$338'.
  created $dff cell `$procdff$681' with positive edge clock.
Creating register for signal `\SB_DFFR.\Q' using process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$335'.
  created $adff cell `$procdff$682' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSR.\Q' using process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$332'.
  created $dff cell `$procdff$683' with positive edge clock.
Creating register for signal `\SB_DFFE.\Q' using process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$330'.
  created $dff cell `$procdff$684' with positive edge clock.
Creating register for signal `\SB_DFF.\Q' using process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$328'.
  created $dff cell `$procdff$685' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$139_ADDR' using process `\regfile.$proc$rtl/regfile.sv:15$140'.
  created $dff cell `$procdff$686' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$139_DATA' using process `\regfile.$proc$rtl/regfile.sv:15$140'.
  created $dff cell `$procdff$687' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$139_EN' using process `\regfile.$proc$rtl/regfile.sv:15$140'.
  created $dff cell `$procdff$688' with positive edge clock.
Creating register for signal `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.\q' using process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$536'.
  created $adff cell `$procdff$689' with positive edge clock and positive level reset.
Creating register for signal `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.\q' using process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$535'.
  created $adff cell `$procdff$690' with positive edge clock and positive level reset.
Creating register for signal `\dmem.\rd' using process `\dmem.$proc$rtl/dmem.sv:30$53'.
  created $dff cell `$procdff$691' with positive edge clock.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:33$52_ADDR' using process `\dmem.$proc$rtl/dmem.sv:30$53'.
  created $dff cell `$procdff$692' with positive edge clock.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:33$52_DATA' using process `\dmem.$proc$rtl/dmem.sv:30$53'.
  created $dff cell `$procdff$693' with positive edge clock.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:33$52_EN' using process `\dmem.$proc$rtl/dmem.sv:30$53'.
  created $dff cell `$procdff$694' with positive edge clock.

16.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

16.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$395'.
Found and cleaned up 1 empty switch in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392'.
Removing empty process `SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$392'.
Removing empty process `SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$391'.
Found and cleaned up 2 empty switches in `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$387'.
Removing empty process `SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$387'.
Removing empty process `SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$386'.
Found and cleaned up 1 empty switch in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383'.
Removing empty process `SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$383'.
Removing empty process `SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$382'.
Found and cleaned up 2 empty switches in `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$378'.
Removing empty process `SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$378'.
Removing empty process `SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$377'.
Removing empty process `SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$375'.
Removing empty process `SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$374'.
Found and cleaned up 1 empty switch in `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$372'.
Removing empty process `SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$372'.
Removing empty process `SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$371'.
Removing empty process `SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$369'.
Removing empty process `SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$368'.
Found and cleaned up 1 empty switch in `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$366'.
Removing empty process `SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$366'.
Removing empty process `SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$365'.
Found and cleaned up 1 empty switch in `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$364'.
Removing empty process `SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$364'.
Removing empty process `SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$363'.
Removing empty process `SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$362'.
Removing empty process `SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$361'.
Found and cleaned up 1 empty switch in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358'.
Removing empty process `SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$358'.
Removing empty process `SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$357'.
Found and cleaned up 2 empty switches in `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$353'.
Removing empty process `SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$353'.
Removing empty process `SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$352'.
Found and cleaned up 1 empty switch in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349'.
Removing empty process `SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$349'.
Removing empty process `SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$348'.
Found and cleaned up 2 empty switches in `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$344'.
Removing empty process `SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$344'.
Removing empty process `SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
Removing empty process `SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$341'.
Removing empty process `SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
Found and cleaned up 1 empty switch in `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$338'.
Removing empty process `SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$338'.
Removing empty process `SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
Removing empty process `SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$335'.
Removing empty process `SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
Found and cleaned up 1 empty switch in `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$332'.
Removing empty process `SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$332'.
Removing empty process `SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$331'.
Found and cleaned up 1 empty switch in `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$330'.
Removing empty process `SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$330'.
Removing empty process `SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$329'.
Removing empty process `SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$328'.
Found and cleaned up 1 empty switch in `\regfile.$proc$rtl/regfile.sv:15$140'.
Removing empty process `regfile.$proc$rtl/regfile.sv:15$140'.
Found and cleaned up 1 empty switch in `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$536'.
Removing empty process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$536'.
Removing empty process `imem.$proc$rtl/imem.sv:0$113'.
Removing empty process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$535'.
Found and cleaned up 1 empty switch in `\extend.$proc$rtl/extend.sv:0$61'.
Removing empty process `extend.$proc$rtl/extend.sv:0$61'.
Found and cleaned up 1 empty switch in `\dmem.$proc$rtl/dmem.sv:30$53'.
Removing empty process `dmem.$proc$rtl/dmem.sv:30$53'.
Found and cleaned up 2 empty switches in `\decoder.$proc$rtl/decoder.sv:0$42'.
Removing empty process `decoder.$proc$rtl/decoder.sv:0$42'.
Found and cleaned up 3 empty switches in `\decoder.$proc$rtl/decoder.sv:0$41'.
Removing empty process `decoder.$proc$rtl/decoder.sv:0$41'.
Found and cleaned up 1 empty switch in `\condcheck.$proc$rtl/condlogic.sv:0$25'.
Removing empty process `condcheck.$proc$rtl/condlogic.sv:0$25'.
Found and cleaned up 1 empty switch in `\alu.$proc$rtl/alu.sv:0$15'.
Removing empty process `alu.$proc$rtl/alu.sv:0$15'.
Cleaned up 29 empty switches.

16.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module regfile.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module imem.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module extend.
<suppressed ~1 debug messages>
Optimizing module dmem.
Optimizing module decoder.
<suppressed ~4 debug messages>
Optimizing module datapath.
Optimizing module cpu_main.
Optimizing module controller.
Optimizing module condcheck.
<suppressed ~1 debug messages>
Optimizing module condlogic.
Optimizing module arm.
Optimizing module alu.
<suppressed ~2 debug messages>
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.

16.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module regfile.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module imem.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module extend.
Optimizing module dmem.
Optimizing module decoder.
Optimizing module datapath.
Optimizing module cpu_main.
Optimizing module controller.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module arm.
Optimizing module alu.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.

16.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \regfile..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Removed 13 unused cells and 128 unused wires.
<suppressed ~27 debug messages>

16.6. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\adder\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010...
Checking module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000...
Checking module alu...
Checking module arm...
Checking module condcheck...
Checking module condlogic...
Checking module controller...
Checking module cpu_main...
Checking module datapath...
Checking module decoder...
Checking module dmem...
Checking module extend...
Checking module imem...
Checking module regfile...
Found and reported 0 problems.

16.7. Executing OPT pass (performing simple optimizations).

16.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
<suppressed ~18 debug messages>
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
<suppressed ~9 debug messages>
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 9 cells.

16.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$630.
    dead port 2/2 on $mux $procmux$638.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 2 multiplexer ports.
<suppressed ~22 debug messages>

16.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
    New ctrl vector for $pmux cell $procmux$611: { $procmux$616_CMP $procmux$614_CMP $auto$opt_reduce.cc:134:opt_pmux$698 $procmux$612_CMP }
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
    Consolidated identical input bits for $mux cell $procmux$598:
      Old ports: A=8'00000000, B=8'11111111, Y=$0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56
      New ports: A=1'0, B=1'1, Y=$0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0]
      New connections: $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [7:1] = { $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] $0$memwr$\RAM$rtl/dmem.sv:33$52_EN[7:0]$56 [0] }
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
    Consolidated identical input bits for $mux cell $procmux$582:
      Old ports: A=0, B=32'11111111111111111111111111111111, Y=$0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143
      New ports: A=1'0, B=1'1, Y=$0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0]
      New connections: $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [31:1] = { $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] $0$memwr$\rf$rtl/regfile.sv:16$139_EN[31:0]$143 [0] }
  Optimizing cells in module \regfile.
Performed a total of 3 changes.

16.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.7.6. Executing OPT_DFF pass (perform DFF optimizations).
Setting constant 0-bit at position 8 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 9 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 10 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 11 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 12 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 13 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 14 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 15 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 16 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 17 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 18 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 19 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 20 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 21 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 22 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 23 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 24 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 25 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 26 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 27 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 28 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 29 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 30 on $procdff$691 ($dff) from module dmem.
Setting constant 0-bit at position 31 on $procdff$691 ($dff) from module dmem.

16.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 11 unused wires.
<suppressed ~2 debug messages>

16.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.9. Rerunning OPT passes. (Maybe there is more to do..)

16.7.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

16.7.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.7.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.7.13. Executing OPT_DFF pass (perform DFF optimizations).

16.7.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.7.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.16. Finished OPT passes. (There is nothing left to do.)

16.8. Executing FSM pass (extract and optimize FSM).

16.8.1. Executing FSM_DETECT pass (finding FSMs in design).

16.8.2. Executing FSM_EXTRACT pass (extracting FSM from design).

16.8.3. Executing FSM_OPT pass (simple optimizations of FSMs).

16.8.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.8.5. Executing FSM_OPT pass (simple optimizations of FSMs).

16.8.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

16.8.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

16.8.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

16.9. Executing OPT pass (performing simple optimizations).

16.9.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

16.9.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.9.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $procdff$689 ($adff) from module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 (D = \d, Q = \q).

16.9.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

16.9.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.9. Rerunning OPT passes. (Maybe there is more to do..)

16.9.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

16.9.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.9.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.13. Executing OPT_DFF pass (perform DFF optimizations).

16.9.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.9.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.16. Finished OPT passes. (There is nothing left to do.)

16.10. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$654_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$655_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$656_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$657_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell condcheck.$procmux$658_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell condcheck.$procmux$659_CMP0 ($eq).
Removed top 3 bits (of 4) from port B of cell condcheck.$procmux$660_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell decoder.$eq$rtl/decoder.sv:47$44 ($eq).
Removed top 2 bits (of 4) from port B of cell decoder.$procmux$615_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell decoder.$procmux$616_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell decoder.$procmux$631_CMP0 ($eq).
Removed top 4 bits (of 10) from mux cell decoder.$procmux$636 ($mux).
Removed top 4 bits (of 10) from wire decoder.$2\controls[9:0].
Removed top 24 bits (of 32) from wire dmem.$0\rd[31:0].
Removed top 1 bits (of 2) from port B of cell extend.$procmux$595_CMP0 ($eq).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:40$89 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:41$90 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:42$91 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:43$92 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:44$93 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:45$94 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:46$95 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:47$96 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:48$97 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:49$98 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:50$99 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:51$100 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:52$101 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:54$102 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:55$103 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:56$104 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:57$105 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:58$106 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:59$107 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:60$108 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:61$109 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:62$110 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:63$111 (RAM).
Removed top 25 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:64$112 (RAM).
Removed top 23 address bits (of 30) from memory read port imem.$memrd$\RAM$rtl/imem.sv:72$88 (RAM).

16.11. Executing PEEPOPT pass (run peephole optimizers).

16.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 2 unused wires.
<suppressed ~2 debug messages>

16.13. Executing SHARE pass (SAT-based resource sharing).
Found 2 cells in module regfile that may be considered for resource sharing.
  Analyzing resource sharing options for $memrd$\rf$rtl/regfile.sv:18$151 ($memrd):
    Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:18$150_Y.
    Found 1 candidates: $memrd$\rf$rtl/regfile.sv:17$148
    Analyzing resource sharing with $memrd$\rf$rtl/regfile.sv:17$148 ($memrd):
      Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:17$147_Y.
      Activation pattern for cell $memrd$\rf$rtl/regfile.sv:18$151: $eq$rtl/regfile.sv:18$150_Y = 1'0
      Activation pattern for cell $memrd$\rf$rtl/regfile.sv:17$148: $eq$rtl/regfile.sv:17$147_Y = 1'0
      Size of SAT problem: 0 cells, 41 variables, 97 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: { $eq$rtl/regfile.sv:18$150_Y $eq$rtl/regfile.sv:17$147_Y } = 2'00
  Analyzing resource sharing options for $memrd$\rf$rtl/regfile.sv:17$148 ($memrd):
    Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:17$147_Y.
    No candidates found.

16.14. Executing TECHMAP pass (map to technology primitives).

16.14.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/cmp2lut.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

16.14.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~6 debug messages>

16.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.17. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000:
  creating $macc model for $add$rtl/adder.sv:4$534 ($add).
  creating $alu model for $macc $add$rtl/adder.sv:4$534.
  creating $alu cell for $add$rtl/adder.sv:4$534: $auto$alumacc.cc:485:replace_alu$704
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module alu:
  creating $macc model for $add$rtl/alu.sv:12$4 ($add).
  creating $macc model for $add$rtl/alu.sv:12$5 ($add).
  merging $macc model for $add$rtl/alu.sv:12$4 into $add$rtl/alu.sv:12$5.
  creating $alu model for $macc $add$rtl/alu.sv:12$5.
  creating $alu cell for $add$rtl/alu.sv:12$5: $auto$alumacc.cc:485:replace_alu$707
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arm:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module condcheck:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module condlogic:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module controller:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module cpu_main:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module datapath:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module decoder:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module dmem:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module extend:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module imem:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module regfile:
  created 0 $alu and 0 $macc cells.

16.18. Executing OPT pass (performing simple optimizations).

16.18.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

16.18.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.18.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.6. Executing OPT_DFF pass (perform DFF optimizations).

16.18.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

16.18.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.9. Rerunning OPT passes. (Maybe there is more to do..)

16.18.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

16.18.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.18.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.13. Executing OPT_DFF pass (perform DFF optimizations).

16.18.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.18.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.16. Finished OPT passes. (There is nothing left to do.)

16.19. Executing MEMORY pass.

16.19.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

16.19.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

16.19.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).
  Analyzing dmem.RAM write port 0.
  Analyzing regfile.rf write port 0.

16.19.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

16.19.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).
Checking read port `\RAM'[0] in module `\dmem': merging output FF to cell.
    Write port 0: non-transparent.
Checking read port `\RAM'[0] in module `\imem': no output FF found.
Checking read port address `\RAM'[0] in module `\imem': no address FF found.
Checking read port `\rf'[0] in module `\regfile': no output FF found.
Checking read port `\rf'[1] in module `\regfile': no output FF found.
Checking read port address `\rf'[0] in module `\regfile': no address FF found.
Checking read port address `\rf'[1] in module `\regfile': no address FF found.

16.19.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 9 unused wires.
<suppressed ~2 debug messages>

16.19.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).
Consolidating read ports of memory regfile.rf by address:

16.19.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

16.19.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.19.10. Executing MEMORY_COLLECT pass (generating $mem cells).

16.20. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.21. Executing MEMORY_LIBMAP pass (mapping memories to cells).
mapping memory dmem.RAM via $__ICE40_RAM4K_
using FF mapping for memory imem.RAM
using FF mapping for memory regfile.rf
<suppressed ~70 debug messages>

16.22. Executing TECHMAP pass (map to technology primitives).

16.22.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K_'.
Successfully finished Verilog frontend.

16.22.2. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/spram_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/spram_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_SPRAM_'.
Successfully finished Verilog frontend.

16.22.3. Continuing TECHMAP pass.
Using template $paramod$13b3947419e62b7bbba1b93c77e4155efbe69a94\$__ICE40_RAM4K_ for cells of type $__ICE40_RAM4K_.
No more expansions possible.
<suppressed ~26 debug messages>

16.23. Executing ICE40_BRAMINIT pass.

16.24. Executing OPT pass (performing simple optimizations).

16.24.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~2 debug messages>
Optimizing module arm.
Optimizing module condcheck.
<suppressed ~1 debug messages>
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~4 debug messages>
Optimizing module dmem.
<suppressed ~20 debug messages>
Optimizing module extend.
<suppressed ~1 debug messages>
Optimizing module imem.
Optimizing module regfile.
<suppressed ~3 debug messages>

16.24.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.24.3. Executing OPT_DFF pass (perform DFF optimizations).
Removing always-active EN on $auto$mem.cc:1134:emulate_transparency$732 ($dffe) from module dmem.

16.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 5 unused cells and 28 unused wires.
<suppressed ~11 debug messages>

16.24.5. Rerunning OPT passes. (Removed registers in this run.)

16.24.6. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.24.7. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.24.8. Executing OPT_DFF pass (perform DFF optimizations).
Setting constant 0-bit at position 6 on $auto$mem.cc:1612:emulate_read_first$729 ($dff) from module dmem.
Setting constant 0-bit at position 7 on $auto$mem.cc:1612:emulate_read_first$729 ($dff) from module dmem.

16.24.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.24.10. Rerunning OPT passes. (Removed registers in this run.)

16.24.11. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.24.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.24.13. Executing OPT_DFF pass (perform DFF optimizations).

16.24.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.24.15. Finished fast OPT passes.

16.25. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).
Mapping memory \RAM in module \imem:
  created 65 $dff cells and 0 static cells of width 32.
  read interface: 0 $dff and 127 $mux cells.
  write interface: 0 write mux blocks.
Mapping memory \rf in module \regfile:
  created 15 $dff cells and 0 static cells of width 32.
  read interface: 0 $dff and 30 $mux cells.
  write interface: 15 write mux blocks.

16.26. Executing OPT pass (performing simple optimizations).

16.26.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
<suppressed ~171 debug messages>
Optimizing module regfile.
<suppressed ~13 debug messages>

16.26.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~30 debug messages>

16.26.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
    Consolidated identical input bits for $mux cell $procmux$628:
      Old ports: A=10'1001110100, B=10'0001111000, Y=$3\controls[9:0]
      New ports: A=2'01, B=2'10, Y=$3\controls[9:0] [3:2]
      New connections: { $3\controls[9:0] [9:4] $3\controls[9:0] [1:0] } = { $3\controls[9:0] [2] 7'0011100 }
    Consolidated identical input bits for $mux cell $procmux$636:
      Old ports: A=6'001001, B=6'101001, Y=$2\controls[9:0]
      New ports: A=1'0, B=1'1, Y=$2\controls[9:0] [5]
      New connections: $2\controls[9:0] [4:0] = 5'01001
  Optimizing cells in module \decoder.
    Consolidated identical input bits for $pmux cell $procmux$641:
      Old ports: A={ 4'0000 $2\controls[9:0] }, B={ $3\controls[9:0] 10'0110100010 }, Y=\controls
      New ports: A={ $2\controls[9:0] [5] 5'01001 }, B={ 2'11 $3\controls[9:0] [3:2] 8'00100010 }, Y=\controls [5:0]
      New connections: \controls [9:6] = { \controls [2:1] \controls [1] \controls [4] }
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
    Consolidated identical input bits for $pmux cell $procmux$593:
      Old ports: A={ 24'000000000000000000000000 \Instr [7:0] }, B={ 20'00000000000000000000 \Instr [11:0] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr 2'00 }, Y=\ExtImm
      New ports: A={ 18'000000000000000000 \Instr [7:0] }, B={ 14'00000000000000 \Instr [11:0] \Instr 2'00 }, Y=\ExtImm [25:0]
      New connections: \ExtImm [31:26] = { \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] }
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][1]$974:
      Old ports: A=32'11100000010011110010000000001111, B=32'11100000010011110011000000001111, Y=$memory\RAM$rdmux[0][5][0]$b$877
      New ports: A=1'0, B=1'1, Y=$memory\RAM$rdmux[0][5][0]$b$877 [12]
      New connections: { $memory\RAM$rdmux[0][5][0]$b$877 [31:13] $memory\RAM$rdmux[0][5][0]$b$877 [11:0] } = 31'1110000001001111001000000001111
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][9]$998:
      Old ports: A=32'11101010111111111111111111110111, B=32'x, Y=$memory\RAM$rdmux[0][5][4]$b$889
      New ports: A=2'01, B=2'x, Y={ $memory\RAM$rdmux[0][5][4]$b$889 [3] $memory\RAM$rdmux[0][5][4]$b$889 [0] }
      New connections: { $memory\RAM$rdmux[0][5][4]$b$889 [31:4] $memory\RAM$rdmux[0][5][4]$b$889 [2:1] } = { $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [3] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [3] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [3] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] $memory\RAM$rdmux[0][5][4]$b$889 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][2]$977:
      Old ports: A=32'11100010100000110011000000000001, B=32'11100000010100110001000000000010, Y=$memory\RAM$rdmux[0][5][1]$a$879
      New ports: A=2'01, B=2'10, Y=$memory\RAM$rdmux[0][5][1]$a$879 [1:0]
      New connections: $memory\RAM$rdmux[0][5][1]$a$879 [31:2] = { 6'111000 $memory\RAM$rdmux[0][5][1]$a$879 [0] 1'0 $memory\RAM$rdmux[0][5][1]$a$879 [0] $memory\RAM$rdmux[0][5][1]$a$879 [1] 1'0 $memory\RAM$rdmux[0][5][1]$a$879 [1] 6'001100 $memory\RAM$rdmux[0][5][1]$a$879 [0] 11'10000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][4]$983:
      Old ports: A=32'11100101100000000011000000010100, B=32'11100000010100110001000000000010, Y=$memory\RAM$rdmux[0][5][2]$a$882
      New ports: A=2'10, B=2'01, Y=$memory\RAM$rdmux[0][5][2]$a$882 [2:1]
      New connections: { $memory\RAM$rdmux[0][5][2]$a$882 [31:3] $memory\RAM$rdmux[0][5][2]$a$882 [0] } = { 5'11100 $memory\RAM$rdmux[0][5][2]$a$882 [2] 1'0 $memory\RAM$rdmux[0][5][2]$a$882 [2] $memory\RAM$rdmux[0][5][2]$a$882 [2:1] 1'0 $memory\RAM$rdmux[0][5][2]$a$882 [1] 2'00 $memory\RAM$rdmux[0][5][2]$a$882 [1] $memory\RAM$rdmux[0][5][2]$a$882 [1] 2'00 $memory\RAM$rdmux[0][5][2]$a$882 [2] 8'10000000 $memory\RAM$rdmux[0][5][2]$a$882 [2] 2'00 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][3]$980:
      Old ports: A=167772163, B=32'11100010100000110011000000000001, Y=$memory\RAM$rdmux[0][5][1]$b$880
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [1] }
      New connections: { $memory\RAM$rdmux[0][5][1]$b$880 [31:13] $memory\RAM$rdmux[0][5][1]$b$880 [11:2] $memory\RAM$rdmux[0][5][1]$b$880 [0] } = { $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [12] 1'0 $memory\RAM$rdmux[0][5][1]$b$880 [1] 3'010 $memory\RAM$rdmux[0][5][1]$b$880 [12] 5'00000 $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [12] 2'00 $memory\RAM$rdmux[0][5][1]$b$880 [12] 11'00000000001 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][5]$986:
      Old ports: A=452984825, B=32'11100101100000000011000000000000, Y=$memory\RAM$rdmux[0][5][2]$b$883
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [0] }
      New connections: { $memory\RAM$rdmux[0][5][2]$b$883 [31:25] $memory\RAM$rdmux[0][5][2]$b$883 [23:1] } = { $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [0] 1'1 $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] 2'11 $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] $memory\RAM$rdmux[0][5][2]$b$883 [0] 2'00 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][6][0]$971:
      Old ports: A=32'11100000010011110000000000001111, B=32'11100000010011110001000000001111, Y=$memory\RAM$rdmux[0][5][0]$a$876
      New ports: A=1'0, B=1'1, Y=$memory\RAM$rdmux[0][5][0]$a$876 [12]
      New connections: { $memory\RAM$rdmux[0][5][0]$a$876 [31:13] $memory\RAM$rdmux[0][5][0]$a$876 [11:0] } = 31'1110000001001111000000000001111
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][0]$875:
      Old ports: A=$memory\RAM$rdmux[0][5][0]$a$876, B=$memory\RAM$rdmux[0][5][0]$b$877, Y=$memory\RAM$rdmux[0][4][0]$a$828
      New ports: A={ 1'0 $memory\RAM$rdmux[0][5][0]$a$876 [12] }, B={ 1'1 $memory\RAM$rdmux[0][5][0]$b$877 [12] }, Y=$memory\RAM$rdmux[0][4][0]$a$828 [13:12]
      New connections: { $memory\RAM$rdmux[0][4][0]$a$828 [31:14] $memory\RAM$rdmux[0][4][0]$a$828 [11:0] } = 30'111000000100111100000000001111
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][1]$878:
      Old ports: A=$memory\RAM$rdmux[0][5][1]$a$879, B=$memory\RAM$rdmux[0][5][1]$b$880, Y=$memory\RAM$rdmux[0][4][0]$b$829
      New ports: A={ 1'0 $memory\RAM$rdmux[0][5][1]$a$879 [1:0] 1'1 $memory\RAM$rdmux[0][5][1]$a$879 [1:0] }, B={ $memory\RAM$rdmux[0][5][1]$b$880 [1] 1'0 $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [12] $memory\RAM$rdmux[0][5][1]$b$880 [1] 1'1 }, Y={ $memory\RAM$rdmux[0][4][0]$b$829 [27] $memory\RAM$rdmux[0][4][0]$b$829 [20] $memory\RAM$rdmux[0][4][0]$b$829 [13:12] $memory\RAM$rdmux[0][4][0]$b$829 [1:0] }
      New connections: { $memory\RAM$rdmux[0][4][0]$b$829 [31:28] $memory\RAM$rdmux[0][4][0]$b$829 [26:21] $memory\RAM$rdmux[0][4][0]$b$829 [19:14] $memory\RAM$rdmux[0][4][0]$b$829 [11:2] } = { $memory\RAM$rdmux[0][4][0]$b$829 [12] $memory\RAM$rdmux[0][4][0]$b$829 [12] $memory\RAM$rdmux[0][4][0]$b$829 [12] 2'00 $memory\RAM$rdmux[0][4][0]$b$829 [0] 1'0 $memory\RAM$rdmux[0][4][0]$b$829 [13] $memory\RAM$rdmux[0][4][0]$b$829 [20] 3'000 $memory\RAM$rdmux[0][4][0]$b$829 [12] $memory\RAM$rdmux[0][4][0]$b$829 [12] 12'000000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][2]$881:
      Old ports: A=$memory\RAM$rdmux[0][5][2]$a$882, B=$memory\RAM$rdmux[0][5][2]$b$883, Y=$memory\RAM$rdmux[0][4][1]$a$831
      New ports: A={ 1'1 $memory\RAM$rdmux[0][5][2]$a$882 [2:1] $memory\RAM$rdmux[0][5][2]$a$882 [2] $memory\RAM$rdmux[0][5][2]$a$882 [2] $memory\RAM$rdmux[0][5][2]$a$882 [2:1] 1'0 }, B={ $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [24] $memory\RAM$rdmux[0][5][2]$b$883 [0] 1'1 $memory\RAM$rdmux[0][5][2]$b$883 [0] 2'00 $memory\RAM$rdmux[0][5][2]$b$883 [0] }, Y={ $memory\RAM$rdmux[0][4][1]$a$831 [29] $memory\RAM$rdmux[0][4][1]$a$831 [24] $memory\RAM$rdmux[0][4][1]$a$831 [16] $memory\RAM$rdmux[0][4][1]$a$831 [13] $memory\RAM$rdmux[0][4][1]$a$831 [4] $memory\RAM$rdmux[0][4][1]$a$831 [2:0] }
      New connections: { $memory\RAM$rdmux[0][4][1]$a$831 [31:30] $memory\RAM$rdmux[0][4][1]$a$831 [28:25] $memory\RAM$rdmux[0][4][1]$a$831 [23:17] $memory\RAM$rdmux[0][4][1]$a$831 [15:14] $memory\RAM$rdmux[0][4][1]$a$831 [12:5] $memory\RAM$rdmux[0][4][1]$a$831 [3] } = { $memory\RAM$rdmux[0][4][1]$a$831 [29] $memory\RAM$rdmux[0][4][1]$a$831 [29] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [24] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [13] $memory\RAM$rdmux[0][4][1]$a$831 [16] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [16] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [16] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] 1'1 $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][4]$887:
      Old ports: A=32'11101010111111111111111111110111, B=$memory\RAM$rdmux[0][5][4]$b$889, Y=$memory\RAM$rdmux[0][4][2]$a$834
      New ports: A=2'01, B={ $memory\RAM$rdmux[0][5][4]$b$889 [3] $memory\RAM$rdmux[0][5][4]$b$889 [0] }, Y={ $memory\RAM$rdmux[0][4][2]$a$834 [3] $memory\RAM$rdmux[0][4][2]$a$834 [0] }
      New connections: { $memory\RAM$rdmux[0][4][2]$a$834 [31:4] $memory\RAM$rdmux[0][4][2]$a$834 [2:1] } = { $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [3] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [3] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [3] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] $memory\RAM$rdmux[0][4][2]$a$834 [0] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][2]$833:
      Old ports: A=$memory\RAM$rdmux[0][4][2]$a$834, B=32'11101010111111111111111111110111, Y=$memory\RAM$rdmux[0][3][1]$a$807
      New ports: A={ $memory\RAM$rdmux[0][4][2]$a$834 [3] $memory\RAM$rdmux[0][4][2]$a$834 [0] }, B=2'01, Y={ $memory\RAM$rdmux[0][3][1]$a$807 [3] $memory\RAM$rdmux[0][3][1]$a$807 [0] }
      New connections: { $memory\RAM$rdmux[0][3][1]$a$807 [31:4] $memory\RAM$rdmux[0][3][1]$a$807 [2:1] } = { $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [3] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [3] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [3] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] $memory\RAM$rdmux[0][3][1]$a$807 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][1]$830:
      Old ports: A=$memory\RAM$rdmux[0][4][1]$a$831, B=32'11101010111111111111111111110111, Y=$memory\RAM$rdmux[0][3][0]$b$805
      New ports: A={ $memory\RAM$rdmux[0][4][1]$a$831 [29] $memory\RAM$rdmux[0][4][1]$a$831 [24] $memory\RAM$rdmux[0][4][1]$a$831 [16] $memory\RAM$rdmux[0][4][1]$a$831 [13] $memory\RAM$rdmux[0][4][1]$a$831 [4] $memory\RAM$rdmux[0][4][1]$a$831 [0] $memory\RAM$rdmux[0][4][1]$a$831 [2:0] }, B=9'101110111, Y={ $memory\RAM$rdmux[0][3][0]$b$805 [29] $memory\RAM$rdmux[0][3][0]$b$805 [24] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [13] $memory\RAM$rdmux[0][3][0]$b$805 [4:0] }
      New connections: { $memory\RAM$rdmux[0][3][0]$b$805 [31:30] $memory\RAM$rdmux[0][3][0]$b$805 [28:25] $memory\RAM$rdmux[0][3][0]$b$805 [23:17] $memory\RAM$rdmux[0][3][0]$b$805 [15:14] $memory\RAM$rdmux[0][3][0]$b$805 [12:5] } = { $memory\RAM$rdmux[0][3][0]$b$805 [29] $memory\RAM$rdmux[0][3][0]$b$805 [29] $memory\RAM$rdmux[0][3][0]$b$805 [3] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [24] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [13] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] 1'1 $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][0]$827:
      Old ports: A=$memory\RAM$rdmux[0][4][0]$a$828, B=$memory\RAM$rdmux[0][4][0]$b$829, Y=$memory\RAM$rdmux[0][3][0]$a$804
      New ports: A={ 6'000101 $memory\RAM$rdmux[0][4][0]$a$828 [13:12] 3'111 }, B={ $memory\RAM$rdmux[0][4][0]$b$829 [27] $memory\RAM$rdmux[0][4][0]$b$829 [0] $memory\RAM$rdmux[0][4][0]$b$829 [13] $memory\RAM$rdmux[0][4][0]$b$829 [20] $memory\RAM$rdmux[0][4][0]$b$829 [20] $memory\RAM$rdmux[0][4][0]$b$829 [12] $memory\RAM$rdmux[0][4][0]$b$829 [13:12] 1'0 $memory\RAM$rdmux[0][4][0]$b$829 [1:0] }, Y={ $memory\RAM$rdmux[0][3][0]$a$804 [27] $memory\RAM$rdmux[0][3][0]$a$804 [25] $memory\RAM$rdmux[0][3][0]$a$804 [23:22] $memory\RAM$rdmux[0][3][0]$a$804 [20] $memory\RAM$rdmux[0][3][0]$a$804 [16] $memory\RAM$rdmux[0][3][0]$a$804 [13:12] $memory\RAM$rdmux[0][3][0]$a$804 [2:0] }
      New connections: { $memory\RAM$rdmux[0][3][0]$a$804 [31:28] $memory\RAM$rdmux[0][3][0]$a$804 [26] $memory\RAM$rdmux[0][3][0]$a$804 [24] $memory\RAM$rdmux[0][3][0]$a$804 [21] $memory\RAM$rdmux[0][3][0]$a$804 [19:17] $memory\RAM$rdmux[0][3][0]$a$804 [15:14] $memory\RAM$rdmux[0][3][0]$a$804 [11:3] } = { $memory\RAM$rdmux[0][3][0]$a$804 [16] $memory\RAM$rdmux[0][3][0]$a$804 [16] $memory\RAM$rdmux[0][3][0]$a$804 [16] 4'0000 $memory\RAM$rdmux[0][3][0]$a$804 [2] $memory\RAM$rdmux[0][3][0]$a$804 [2] $memory\RAM$rdmux[0][3][0]$a$804 [16] 10'0000000000 $memory\RAM$rdmux[0][3][0]$a$804 [2] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][3][1]$806:
      Old ports: A=$memory\RAM$rdmux[0][3][1]$a$807, B=32'x, Y=$memory\RAM$rdmux[0][2][0]$b$793
      New ports: A={ $memory\RAM$rdmux[0][3][1]$a$807 [3] $memory\RAM$rdmux[0][3][1]$a$807 [0] }, B=2'x, Y={ $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] }
      New connections: { $memory\RAM$rdmux[0][2][0]$b$793 [31:4] $memory\RAM$rdmux[0][2][0]$b$793 [2:1] } = { $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][3][0]$803:
      Old ports: A=$memory\RAM$rdmux[0][3][0]$a$804, B=$memory\RAM$rdmux[0][3][0]$b$805, Y=$memory\RAM$rdmux[0][2][0]$a$792
      New ports: A={ $memory\RAM$rdmux[0][3][0]$a$804 [16] 1'0 $memory\RAM$rdmux[0][3][0]$a$804 [27] $memory\RAM$rdmux[0][3][0]$a$804 [25] 1'0 $memory\RAM$rdmux[0][3][0]$a$804 [23:22] $memory\RAM$rdmux[0][3][0]$a$804 [20] $memory\RAM$rdmux[0][3][0]$a$804 [2] $memory\RAM$rdmux[0][3][0]$a$804 [16] $memory\RAM$rdmux[0][3][0]$a$804 [13:12] 2'00 $memory\RAM$rdmux[0][3][0]$a$804 [2] $memory\RAM$rdmux[0][3][0]$a$804 [2:0] }, B={ $memory\RAM$rdmux[0][3][0]$b$805 [29] $memory\RAM$rdmux[0][3][0]$b$805 [3] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [24] $memory\RAM$rdmux[0][3][0]$b$805 [13] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [16] $memory\RAM$rdmux[0][3][0]$b$805 [13] 1'1 $memory\RAM$rdmux[0][3][0]$b$805 [0] $memory\RAM$rdmux[0][3][0]$b$805 [4:0] }, Y={ $memory\RAM$rdmux[0][2][0]$a$792 [29:27] $memory\RAM$rdmux[0][2][0]$a$792 [25:22] $memory\RAM$rdmux[0][2][0]$a$792 [20] $memory\RAM$rdmux[0][2][0]$a$792 [18] $memory\RAM$rdmux[0][2][0]$a$792 [16] $memory\RAM$rdmux[0][2][0]$a$792 [13:12] $memory\RAM$rdmux[0][2][0]$a$792 [5:0] }
      New connections: { $memory\RAM$rdmux[0][2][0]$a$792 [31:30] $memory\RAM$rdmux[0][2][0]$a$792 [26] $memory\RAM$rdmux[0][2][0]$a$792 [21] $memory\RAM$rdmux[0][2][0]$a$792 [19] $memory\RAM$rdmux[0][2][0]$a$792 [17] $memory\RAM$rdmux[0][2][0]$a$792 [15:14] $memory\RAM$rdmux[0][2][0]$a$792 [11:6] } = { $memory\RAM$rdmux[0][2][0]$a$792 [29] $memory\RAM$rdmux[0][2][0]$a$792 [29] $memory\RAM$rdmux[0][2][0]$a$792 [24] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [18] $memory\RAM$rdmux[0][2][0]$a$792 [16] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] $memory\RAM$rdmux[0][2][0]$a$792 [5] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][2][0]$791:
      Old ports: A=$memory\RAM$rdmux[0][2][0]$a$792, B=$memory\RAM$rdmux[0][2][0]$b$793, Y=$memory\RAM$rdmux[0][1][0]$a$786
      New ports: A={ $memory\RAM$rdmux[0][2][0]$a$792 [29:27] $memory\RAM$rdmux[0][2][0]$a$792 [25:22] $memory\RAM$rdmux[0][2][0]$a$792 [20] $memory\RAM$rdmux[0][2][0]$a$792 [18] $memory\RAM$rdmux[0][2][0]$a$792 [16] $memory\RAM$rdmux[0][2][0]$a$792 [13:12] $memory\RAM$rdmux[0][2][0]$a$792 [5:0] }, B={ $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [3] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] $memory\RAM$rdmux[0][2][0]$b$793 [0] }, Y={ $memory\RAM$rdmux[0][1][0]$a$786 [29:27] $memory\RAM$rdmux[0][1][0]$a$786 [25:22] $memory\RAM$rdmux[0][1][0]$a$786 [20] $memory\RAM$rdmux[0][1][0]$a$786 [18] $memory\RAM$rdmux[0][1][0]$a$786 [16] $memory\RAM$rdmux[0][1][0]$a$786 [13:12] $memory\RAM$rdmux[0][1][0]$a$786 [5:0] }
      New connections: { $memory\RAM$rdmux[0][1][0]$a$786 [31:30] $memory\RAM$rdmux[0][1][0]$a$786 [26] $memory\RAM$rdmux[0][1][0]$a$786 [21] $memory\RAM$rdmux[0][1][0]$a$786 [19] $memory\RAM$rdmux[0][1][0]$a$786 [17] $memory\RAM$rdmux[0][1][0]$a$786 [15:14] $memory\RAM$rdmux[0][1][0]$a$786 [11:6] } = { $memory\RAM$rdmux[0][1][0]$a$786 [29] $memory\RAM$rdmux[0][1][0]$a$786 [29] $memory\RAM$rdmux[0][1][0]$a$786 [24] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [18] $memory\RAM$rdmux[0][1][0]$a$786 [16] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] $memory\RAM$rdmux[0][1][0]$a$786 [5] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][1][0]$785:
      Old ports: A=$memory\RAM$rdmux[0][1][0]$a$786, B=32'x, Y=$memory\RAM$rdmux[0][0][0]$a$783
      New ports: A={ $memory\RAM$rdmux[0][1][0]$a$786 [29:27] $memory\RAM$rdmux[0][1][0]$a$786 [25:22] $memory\RAM$rdmux[0][1][0]$a$786 [20] $memory\RAM$rdmux[0][1][0]$a$786 [18] $memory\RAM$rdmux[0][1][0]$a$786 [16] $memory\RAM$rdmux[0][1][0]$a$786 [13:12] $memory\RAM$rdmux[0][1][0]$a$786 [5:0] }, B=18'x, Y={ $memory\RAM$rdmux[0][0][0]$a$783 [29:27] $memory\RAM$rdmux[0][0][0]$a$783 [25:22] $memory\RAM$rdmux[0][0][0]$a$783 [20] $memory\RAM$rdmux[0][0][0]$a$783 [18] $memory\RAM$rdmux[0][0][0]$a$783 [16] $memory\RAM$rdmux[0][0][0]$a$783 [13:12] $memory\RAM$rdmux[0][0][0]$a$783 [5:0] }
      New connections: { $memory\RAM$rdmux[0][0][0]$a$783 [31:30] $memory\RAM$rdmux[0][0][0]$a$783 [26] $memory\RAM$rdmux[0][0][0]$a$783 [21] $memory\RAM$rdmux[0][0][0]$a$783 [19] $memory\RAM$rdmux[0][0][0]$a$783 [17] $memory\RAM$rdmux[0][0][0]$a$783 [15:14] $memory\RAM$rdmux[0][0][0]$a$783 [11:6] } = { $memory\RAM$rdmux[0][0][0]$a$783 [29] $memory\RAM$rdmux[0][0][0]$a$783 [29] $memory\RAM$rdmux[0][0][0]$a$783 [24] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [18] $memory\RAM$rdmux[0][0][0]$a$783 [16] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] $memory\RAM$rdmux[0][0][0]$a$783 [5] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][0][0]$782:
      Old ports: A=$memory\RAM$rdmux[0][0][0]$a$783, B=32'x, Y=\rd
      New ports: A={ $memory\RAM$rdmux[0][0][0]$a$783 [29:27] $memory\RAM$rdmux[0][0][0]$a$783 [25:22] $memory\RAM$rdmux[0][0][0]$a$783 [20] $memory\RAM$rdmux[0][0][0]$a$783 [18] $memory\RAM$rdmux[0][0][0]$a$783 [16] $memory\RAM$rdmux[0][0][0]$a$783 [13:12] $memory\RAM$rdmux[0][0][0]$a$783 [5:0] }, B=18'x, Y={ \rd [29:27] \rd [25:22] \rd [20] \rd [18] \rd [16] \rd [13:12] \rd [5:0] }
      New connections: { \rd [31:30] \rd [26] \rd [21] \rd [19] \rd [17] \rd [15:14] \rd [11:6] } = { \rd [29] \rd [29] \rd [24] \rd [5] \rd [18] \rd [16] \rd [5] \rd [5] \rd [5] \rd [5] \rd [5] \rd [5] \rd [5] \rd [5] }
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 23 changes.

16.26.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
<suppressed ~9 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 3 cells.

16.26.6. Executing OPT_DFF pass (perform DFF optimizations).

16.26.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 290 unused wires.
<suppressed ~2 debug messages>

16.26.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.9. Rerunning OPT passes. (Maybe there is more to do..)

16.26.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~31 debug messages>

16.26.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][0]$875:
      Old ports: A={ 1'0 $memory\RAM$rdmux[0][5][0]$a$876 [12] }, B={ 1'1 $memory\RAM$rdmux[0][5][0]$a$876 [12] }, Y=$memory\RAM$rdmux[0][4][0]$a$828 [13:12]
      New ports: A=1'0, B=1'1, Y=$memory\RAM$rdmux[0][4][0]$a$828 [13]
      New connections: $memory\RAM$rdmux[0][4][0]$a$828 [12] = $memory\RAM$rdmux[0][5][0]$a$876 [12]
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 1 changes.

16.26.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.13. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $memory\rf[9]$1181 ($dff) from module regfile (D = \wd3, Q = \rf[9]).
Adding EN signal on $memory\rf[8]$1179 ($dff) from module regfile (D = \wd3, Q = \rf[8]).
Adding EN signal on $memory\rf[7]$1177 ($dff) from module regfile (D = \wd3, Q = \rf[7]).
Adding EN signal on $memory\rf[6]$1175 ($dff) from module regfile (D = \wd3, Q = \rf[6]).
Adding EN signal on $memory\rf[5]$1173 ($dff) from module regfile (D = \wd3, Q = \rf[5]).
Adding EN signal on $memory\rf[4]$1171 ($dff) from module regfile (D = \wd3, Q = \rf[4]).
Adding EN signal on $memory\rf[3]$1169 ($dff) from module regfile (D = \wd3, Q = \rf[3]).
Adding EN signal on $memory\rf[2]$1167 ($dff) from module regfile (D = \wd3, Q = \rf[2]).
Adding EN signal on $memory\rf[1]$1165 ($dff) from module regfile (D = \wd3, Q = \rf[1]).
Adding EN signal on $memory\rf[14]$1191 ($dff) from module regfile (D = \wd3, Q = \rf[14]).
Adding EN signal on $memory\rf[13]$1189 ($dff) from module regfile (D = \wd3, Q = \rf[13]).
Adding EN signal on $memory\rf[12]$1187 ($dff) from module regfile (D = \wd3, Q = \rf[12]).
Adding EN signal on $memory\rf[11]$1185 ($dff) from module regfile (D = \wd3, Q = \rf[11]).
Adding EN signal on $memory\rf[10]$1183 ($dff) from module regfile (D = \wd3, Q = \rf[10]).
Adding EN signal on $memory\rf[0]$1163 ($dff) from module regfile (D = \wd3, Q = \rf[0]).

16.26.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 15 unused cells and 16 unused wires.
<suppressed ~17 debug messages>

16.26.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.16. Rerunning OPT passes. (Maybe there is more to do..)

16.26.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~16 debug messages>

16.26.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.26.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.20. Executing OPT_DFF pass (perform DFF optimizations).

16.26.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.26.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.23. Finished OPT passes. (There is nothing left to do.)

16.27. Executing ICE40_WRAPCARRY pass (wrap carries).

16.28. Executing TECHMAP pass (map to technology primitives).

16.28.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.28.2. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

16.28.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $dffe.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $and.
Using template $paramod$55fabc38af77a7e92aab69f00033bfed03b847e2\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $dff.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $or.
Using template $paramod$97565c3687be688407d1272a293bd9d0ae6852dc\_90_pmux for cells of type $pmux.
Using template $paramod$ed0bb9616228df1e6c226f91f8133e751815f1b1\_90_pmux for cells of type $pmux.
Using template $paramod$3ab9a015ab781a81f86ab59e92093de7732cf40e\_90_pmux for cells of type $pmux.
Using template $paramod$857150d3a9b7fb38b73bbaa31ff652415e553f98\_80_ice40_alu for cells of type $alu.
Using template $paramod$8fabc56b80a569262acfc42757a02ca0b8e91278\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $adff.
Using extmapper simplemap for cells of type $adffe.
Using template $paramod$fbc7873bff55778c0b3173955b7e4bce1d9d6834\_80_ice40_alu for cells of type $alu.
No more expansions possible.
<suppressed ~468 debug messages>

16.29. Executing OPT pass (performing simple optimizations).

16.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
<suppressed ~32 debug messages>
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~39 debug messages>
Optimizing module arm.
Optimizing module condcheck.
<suppressed ~58 debug messages>
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~51 debug messages>
Optimizing module dmem.
Optimizing module extend.
<suppressed ~36 debug messages>
Optimizing module imem.
<suppressed ~4 debug messages>
Optimizing module regfile.
<suppressed ~72 debug messages>

16.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
<suppressed ~3 debug messages>
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
<suppressed ~132 debug messages>
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
<suppressed ~21 debug messages>
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
<suppressed ~21 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 59 cells.

16.29.3. Executing OPT_DFF pass (perform DFF optimizations).

16.29.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 131 unused cells and 419 unused wires.
<suppressed ~140 debug messages>

16.29.5. Finished fast OPT passes.

16.30. Executing ICE40_OPT pass (performing simple optimizations).

16.30.1. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) alu.$auto$alumacc.cc:485:replace_alu$707.slice[32].carry: CO=1'0

16.30.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~1 debug messages>
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
<suppressed ~45 debug messages>
Optimizing module regfile.
<suppressed ~64 debug messages>

16.30.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.30.4. Executing OPT_DFF pass (perform DFF optimizations).

16.30.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 10 unused wires.
<suppressed ~3 debug messages>

16.30.6. Rerunning OPT passes. (Removed registers in this run.)

16.30.7. Running ICE40 specific optimizations.

16.30.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.30.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.30.10. Executing OPT_DFF pass (perform DFF optimizations).

16.30.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.30.12. Finished OPT passes. (There is nothing left to do.)

16.31. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).

16.32. Executing TECHMAP pass (map to technology primitives).

16.32.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

16.32.2. Continuing TECHMAP pass.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
Using template \$_DFF_PP0_ for cells of type $_DFF_PP0_.
Using template \$_DFFE_PP0P_ for cells of type $_DFFE_PP0P_.
No more expansions possible.
<suppressed ~560 debug messages>

16.33. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.34. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping alu.$auto$alumacc.cc:485:replace_alu$707.slice[32].carry ($lut).

16.35. Executing ICE40_OPT pass (performing simple optimizations).

16.35.1. Running ICE40 specific optimizations.

16.35.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~15 debug messages>
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~5 debug messages>
Optimizing module dmem.
Optimizing module extend.
<suppressed ~18 debug messages>
Optimizing module imem.
<suppressed ~33 debug messages>
Optimizing module regfile.

16.35.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.35.4. Executing OPT_DFF pass (perform DFF optimizations).

16.35.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 2672 unused wires.
<suppressed ~5 debug messages>

16.35.6. Rerunning OPT passes. (Removed registers in this run.)

16.35.7. Running ICE40 specific optimizations.

16.35.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.35.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.35.10. Executing OPT_DFF pass (perform DFF optimizations).

16.35.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.35.12. Finished OPT passes. (There is nothing left to do.)

16.36. Executing TECHMAP pass (map to technology primitives).

16.36.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

16.36.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~4 debug messages>

16.37. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/abc9_model.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/abc9_model.v' to AST representation.
Generating RTLIL representation for module `$__ICE40_CARRY_WRAPPER'.
Successfully finished Verilog frontend.

16.38. Executing ABC9 pass.

16.38.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.3. Executing SCC pass (detecting logic loops).
Found 0 SCCs in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Found 0 SCCs in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Found 0 SCCs in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module alu.
Found 0 SCCs in module arm.
Found 0 SCCs in module condcheck.
Found 0 SCCs in module condlogic.
Found 0 SCCs in module controller.
Found 0 SCCs in module cpu_main.
Found 0 SCCs in module datapath.
Found 0 SCCs in module decoder.
Found 0 SCCs in module dmem.
Found 0 SCCs in module extend.
Found 0 SCCs in module imem.
Found 0 SCCs in module regfile.
Found 0 SCCs.

16.38.4. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.5. Executing PROC pass (convert processes to netlists).

16.38.5.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.38.5.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

16.38.5.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

16.38.5.4. Executing PROC_INIT pass (extract init attributes).

16.38.5.5. Executing PROC_ARST pass (detect async resets in processes).

16.38.5.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

16.38.5.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

16.38.5.8. Executing PROC_DLATCH pass (convert process syncs to latches).

16.38.5.9. Executing PROC_DFF pass (convert process syncs to FFs).

16.38.5.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

16.38.5.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.38.5.12. Executing OPT_EXPR pass (perform const folding).

16.38.6. Executing TECHMAP pass (map to technology primitives).

16.38.6.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.38.6.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~143 debug messages>

16.38.7. Executing OPT pass (performing simple optimizations).

16.38.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module SB_DFFER.
Optimizing module SB_DFFR.

16.38.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\SB_DFFER'.
Finding identical cells in module `\SB_DFFR'.
Removed a total of 0 cells.

16.38.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \SB_DFFER..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \SB_DFFR..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \SB_DFFER.
  Optimizing cells in module \SB_DFFR.
Performed a total of 0 changes.

16.38.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\SB_DFFER'.
Finding identical cells in module `\SB_DFFR'.
Removed a total of 0 cells.

16.38.7.6. Executing OPT_DFF pass (perform DFF optimizations).

16.38.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \SB_DFFER..
Finding unused cells or wires in module \SB_DFFR..

16.38.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module SB_DFFER.
Optimizing module SB_DFFR.

16.38.7.9. Finished OPT passes. (There is nothing left to do.)

16.38.8. Executing TECHMAP pass (map to technology primitives).

16.38.8.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_map.v' to AST representation.
Successfully finished Verilog frontend.

16.38.8.2. Continuing TECHMAP pass.
Using template SB_DFFR for cells of type SB_DFFR.
Using template SB_DFFER for cells of type SB_DFFER.
No more expansions possible.
<suppressed ~38 debug messages>

16.38.9. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_model.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_model.v' to AST representation.
Generating RTLIL representation for module `$__ABC9_DELAY'.
Generating RTLIL representation for module `$__ABC9_SCC_BREAKER'.
Generating RTLIL representation for module `$__DFF_N__$abc9_flop'.
Generating RTLIL representation for module `$__DFF_P__$abc9_flop'.
Successfully finished Verilog frontend.

16.38.10. Executing ABC9_OPS pass (helper functions for ABC9).
<suppressed ~68 debug messages>

16.38.11. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.12. Executing ABC9_OPS pass (helper functions for ABC9).
<suppressed ~2 debug messages>

16.38.13. Executing TECHMAP pass (map to technology primitives).

16.38.13.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.38.13.2. Continuing TECHMAP pass.
Using template $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 for cells of type $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1.
Using template $paramod\SB_LUT4\LUT_INIT=16'0110100110010110 for cells of type SB_LUT4.
Using template SB_CARRY for cells of type SB_CARRY.
Using extmapper simplemap for cells of type $logic_or.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $logic_and.
No more expansions possible.
<suppressed ~180 debug messages>

16.38.14. Executing OPT pass (performing simple optimizations).

16.38.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
<suppressed ~4 debug messages>
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~4 debug messages>
Optimizing module dmem.

16.38.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
<suppressed ~29 debug messages>
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
<suppressed ~29 debug messages>
Finding identical cells in module `\dmem'.
Removed a total of 24 cells.

16.38.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \dmem.
Performed a total of 0 changes.

16.38.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\dmem'.
Removed a total of 0 cells.

16.38.14.6. Executing OPT_DFF pass (perform DFF optimizations).

16.38.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \dmem..
Removed 0 unused cells and 48 unused wires.
<suppressed ~2 debug messages>

16.38.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module dmem.

16.38.14.9. Rerunning OPT passes. (Maybe there is more to do..)

16.38.14.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.14.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \dmem.
Performed a total of 0 changes.

16.38.14.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\dmem'.
Removed a total of 0 cells.

16.38.14.13. Executing OPT_DFF pass (perform DFF optimizations).

16.38.14.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \dmem..

16.38.14.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module dmem.

16.38.14.16. Finished OPT passes. (There is nothing left to do.)

16.38.15. Executing AIGMAP pass (map logic to AIG).
Module $paramod\adder\WIDTH=s32'00000000000000000000000000100000: replaced 7 cells with 43 new cells, skipped 11 cells.
  replaced 2 cell types:
       2 $_OR_
       5 $_MUX_
  not replaced 3 cell types:
       8 $specify2
       1 $_NOT_
       2 $_AND_
Module alu: replaced 7 cells with 43 new cells, skipped 11 cells.
  replaced 2 cell types:
       2 $_OR_
       5 $_MUX_
  not replaced 3 cell types:
       8 $specify2
       1 $_NOT_
       2 $_AND_

16.38.16. Executing AIGMAP pass (map logic to AIG).
Module $paramod\adder\WIDTH=s32'00000000000000000000000000100000: replaced 0 cells with 0 new cells, skipped 32 cells.
  not replaced 1 cell types:
      32 $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1
Module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010: replaced 0 cells with 0 new cells, skipped 4 cells.
  not replaced 2 cell types:
       2 SB_DFFER
       2 SB_DFFER_$abc9_byp
Module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000: replaced 0 cells with 0 new cells, skipped 64 cells.
  not replaced 2 cell types:
      32 SB_DFFR
      32 SB_DFFR_$abc9_byp
Module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100: replaced 4 cells with 28 new cells, skipped 0 cells.
  replaced 1 cell types:
       4 $_MUX_
Module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000: replaced 32 cells with 224 new cells, skipped 0 cells.
  replaced 1 cell types:
      32 $_MUX_
Module alu: replaced 162 cells with 840 new cells, skipped 165 cells.
  replaced 2 cell types:
      98 $_OR_
      64 $_MUX_
  not replaced 3 cell types:
      37 $_NOT_
      96 $_AND_
      32 $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1
Module arm: replaced 0 cells with 0 new cells, skipped 2 cells.
  not replaced 2 cell types:
       1 controller
       1 datapath
Module condcheck: replaced 50 cells with 206 new cells, skipped 40 cells.
  replaced 3 cell types:
      48 $_OR_
       1 $_XOR_
       1 $_MUX_
  not replaced 2 cell types:
      25 $_NOT_
      15 $_AND_
Module condlogic: replaced 0 cells with 0 new cells, skipped 10 cells.
  not replaced 4 cell types:
       1 $_NOT_
       6 $_AND_
       1 condcheck
       2 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Module controller: replaced 0 cells with 0 new cells, skipped 2 cells.
  not replaced 2 cell types:
       1 condlogic
       1 decoder
Module cpu_main: replaced 0 cells with 0 new cells, skipped 3 cells.
  not replaced 3 cell types:
       1 arm
       1 imem
       1 dmem
Module datapath: replaced 0 cells with 0 new cells, skipped 11 cells.
  not replaced 7 cell types:
       1 alu
       1 regfile
       1 extend
       3 $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
       2 $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
       2 $paramod\adder\WIDTH=s32'00000000000000000000000000100000
       1 $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Module decoder: replaced 29 cells with 134 new cells, skipped 29 cells.
  replaced 2 cell types:
      23 $_OR_
       6 $_MUX_
  not replaced 2 cell types:
      20 $_NOT_
       9 $_AND_
Module dmem: replaced 19 cells with 118 new cells, skipped 85 cells.
  replaced 3 cell types:
       5 $_OR_
       6 $_XOR_
       8 $_MUX_
  not replaced 11 cell types:
       1 $_NOT_
       1 $_AND_
      24 SB_DFF
       1 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000010111001
       1 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000011111100
      16 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000100110001
      11 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000110101000
       2 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000111110111
      11 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000000110000000
      16 $paramod$__ABC9_DELAY\DELAY=32'00000000000000000000001000000101
       1 $paramod$ba68a0420314c29d51ab7ddbd2ec9361aa29f018\SB_RAM40_4K
Module extend: replaced 21 cells with 108 new cells, skipped 58 cells.
  replaced 2 cell types:
      13 $_OR_
       8 $_MUX_
  not replaced 2 cell types:
       4 $_NOT_
      54 $_AND_
Module imem: replaced 53 cells with 299 new cells, skipped 11 cells.
  replaced 2 cell types:
      24 $_OR_
      29 $_MUX_
  not replaced 2 cell types:
       2 $_NOT_
       9 $_AND_
Module regfile: replaced 966 cells with 6744 new cells, skipped 530 cells.
  replaced 2 cell types:
       6 $_OR_
     960 $_MUX_
  not replaced 3 cell types:
      12 $_NOT_
      38 $_AND_
     480 SB_DFFE

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~11 debug messages>
Extracted 0 AND gates and 130 wires from module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 64 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 32  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 32  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 32  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =   32  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~204 debug messages>
Removed 0 unused cells and 321 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 cells:       32
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~13 debug messages>
Extracted 0 AND gates and 11 wires from module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010' to a netlist network with 7 inputs and 2 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 2  bb = 2
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 2  bb = 2
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.00 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 2  bb = 2
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =    1  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~30 debug messages>
Removed 0 unused cells and 15 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   \SB_DFFER_$abc9_byp cells:        2
ABC RESULTS:           input signals:        6
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~43 debug messages>
Extracted 0 AND gates and 100 wires from module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 66 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 32  bb = 32
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 32  bb = 32
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.03 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 32  bb = 32
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =    1  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~208 debug messages>
Removed 0 unused cells and 194 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   \SB_DFFR_$abc9_byp cells:       32
ABC RESULTS:           input signals:       35
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 12 AND gates and 39 wires from module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100' to a netlist network with 9 inputs and 4 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      12  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      24  lev =    2 (2.00)  mem = 0.00 MB  ch =    4  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      24.  Ch =     4.  Total mem =    0.01 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: F:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      12  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =      4  edge =      12  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 4 : 2=0 0.0 %  3=4 100.0 %  Ave = 3.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~34 debug messages>
Removed 17 unused cells and 30 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:        4
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 96 AND gates and 291 wires from module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 65 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =      96  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =     192  lev =    2 (2.00)  mem = 0.00 MB  ch =   32  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     192.  Ch =    32.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: F:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =      96  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =     32  edge =      96  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 32 : 2=0 0.0 %  3=32 100.0 %  Ave = 3.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~202 debug messages>
Removed 129 unused cells and 226 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       32
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~11 debug messages>
Extracted 386 AND gates and 1109 wires from module `alu' to a netlist network with 66 inputs and 36 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     386  lev =   10 (1.27)  mem = 0.01 MB  box = 32  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     701  lev =   24 (1.09)  mem = 0.01 MB  ch =   75  box = 32  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     701.  Ch =    73.  Total mem =    0.14 MB. Peak cut mem =    0.02 MB.
ABC: P:  Del = 16703.00.  Ar =     108.0.  Edge =      335.  Cut =     3213.  T =     0.00 sec
ABC: P:  Del = 16703.00.  Ar =     107.0.  Edge =      332.  Cut =     3002.  T =     0.00 sec
ABC: P:  Del = 16703.00.  Ar =     109.0.  Edge =      332.  Cut =     3139.  T =     0.00 sec
ABC: F:  Del = 16703.00.  Ar =     108.0.  Edge =      331.  Cut =     2860.  T =     0.00 sec
ABC: A:  Del = 16703.00.  Ar =     107.0.  Edge =      330.  Cut =     2673.  T =     0.00 sec
ABC: A:  Del = 16703.00.  Ar =     107.0.  Edge =      330.  Cut =     2866.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     383  lev =   13 (1.30)  mem = 0.01 MB  box = 32  bb = 0
ABC: Mapping (K=4)  :  lut =    107  edge =     330  lev =    6 (0.56)  levB =   36  mem = 0.00 MB
ABC: LUT = 107 : 2=33 30.8 %  3=32 29.9 %  4=42 39.3 %  Ave = 3.08
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.02 seconds, total: 0.02 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~216 debug messages>
Removed 630 unused cells and 955 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:      107
ABC RESULTS:   $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 cells:       32
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        2
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 179 wires from module `arm' to a netlist network with 177 inputs and 111 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~584 debug messages>
Removed 0 unused cells and 288 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        4
ABC RESULTS:          output signals:       12
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 69 AND gates and 256 wires from module `condcheck' to a netlist network with 8 inputs and 1 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      69  lev =   10 (10.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      83  lev =    8 (8.00)  mem = 0.00 MB  ch =    8  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      83.  Ch =     6.  Total mem =    0.01 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      447.  T =     0.00 sec
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      429.  T =     0.00 sec
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      422.  T =     0.00 sec
ABC: F:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      345.  T =     0.00 sec
ABC: A:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      346.  T =     0.00 sec
ABC: A:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      346.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      75  lev =    8 (8.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     22  edge =      75  lev =    4 (4.00)  mem = 0.00 MB
ABC: LUT = 22 : 2=6 27.3 %  3=1 4.5 %  4=15 68.2 %  Ave = 3.41
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~26 debug messages>
Removed 100 unused cells and 109 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       22
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 6 AND gates and 30 wires from module `condlogic' to a netlist network with 21 inputs and 9 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     21/      9  and =       6  lev =    2 (0.67)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     21/      9  and =       8  lev =    2 (0.67)  mem = 0.00 MB  ch =    1  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       8.  Ch =     1.  Total mem =    0.01 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: F:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       5.0.  Edge =       11.  Cut =       10.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     21/      9  and =       6  lev =    2 (0.67)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =      5  edge =      11  lev =    1 (0.56)  mem = 0.00 MB
ABC: LUT = 5 : 2=4 80.0 %  3=1 20.0 %  Ave = 2.20
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~68 debug messages>
Removed 2 unused cells and 32 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:        5
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:        5
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 45 wires from module `controller' to a netlist network with 43 inputs and 17 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     43/     17  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     43/     17  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.01 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     43/     17  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~128 debug messages>
Removed 0 unused cells and 60 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        4
ABC RESULTS:          output signals:       13
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 166 wires from module `cpu_main' to a netlist network with 164 inputs and 161 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    164/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    164/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    164/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~658 debug messages>
Removed 0 unused cells and 325 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        6
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 410 wires from module `datapath' to a netlist network with 408 inputs and 332 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.10 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~1488 debug messages>
Removed 0 unused cells and 740 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:       11
ABC RESULTS:          output signals:       13
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 50 AND gates and 185 wires from module `decoder' to a netlist network with 12 inputs and 14 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     12/     14  and =      40  lev =   10 (4.36)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     12/     14  and =      32  lev =    4 (2.57)  mem = 0.00 MB  ch =    3  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      32.  Ch =     3.  Total mem =    0.01 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 3659.00.  Ar =      14.0.  Edge =       46.  Cut =      130.  T =     0.00 sec
ABC: P:  Del = 3659.00.  Ar =      14.0.  Edge =       46.  Cut =      130.  T =     0.00 sec
ABC: P:  Del = 3659.00.  Ar =      14.0.  Edge =       46.  Cut =      134.  T =     0.00 sec
ABC: F:  Del = 3659.00.  Ar =      14.0.  Edge =       46.  Cut =      107.  T =     0.00 sec
ABC: A:  Del = 3659.00.  Ar =      14.0.  Edge =       45.  Cut =      107.  T =     0.00 sec
ABC: A:  Del = 3659.00.  Ar =      14.0.  Edge =       45.  Cut =      107.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     12/     14  and =      50  lev =    4 (2.57)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     14  edge =      45  lev =    2 (1.43)  mem = 0.00 MB
ABC: LUT = 14 : 2=3 21.4 %  3=5 35.7 %  4=6 42.9 %  Ave = 3.21
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~60 debug messages>
Removed 66 unused cells and 89 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       14
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:       10
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~51 debug messages>
Extracted 48 AND gates and 278 wires from module `dmem' to a netlist network with 74 inputs and 99 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     74/     99  and =      48  lev =    6 (0.14)  mem = 0.01 MB  box = 58  bb = 58
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     74/     99  and =      98  lev =    5 (0.13)  mem = 0.01 MB  ch =   12  box = 58  bb = 58
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      98.  Ch =    11.  Total mem =    0.05 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      323.  T =     0.00 sec
ABC: P:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      320.  T =     0.00 sec
ABC: P:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      321.  T =     0.00 sec
ABC: F:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      309.  T =     0.00 sec
ABC: A:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      309.  T =     0.00 sec
ABC: A:  Del = 6263.00.  Ar =      14.0.  Edge =       44.  Cut =      309.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     74/     99  and =      48  lev =    5 (0.13)  mem = 0.01 MB  box = 58  bb = 58
ABC: Mapping (K=4)  :  lut =     14  edge =      44  lev =    3 (0.07)  levB =    3  mem = 0.00 MB
ABC: LUT = 14 : 2=2 14.3 %  3=8 57.1 %  4=4 28.6 %  Ave = 3.14
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~358 debug messages>
Removed 78 unused cells and 374 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       14
ABC RESULTS:           input signals:        9
ABC RESULTS:          output signals:       61
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 91 AND gates and 200 wires from module `extend' to a netlist network with 26 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      91  lev =    5 (3.56)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      66  lev =    3 (2.31)  mem = 0.00 MB  ch =    6  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      66.  Ch =     6.  Total mem =    0.02 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: F:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      76  lev =    3 (2.31)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     26  edge =      88  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 26 : 2=0 0.0 %  3=16 61.5 %  4=10 38.5 %  Ave = 3.38
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~124 debug messages>
Removed 80 unused cells and 132 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       26
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 120 AND gates and 358 wires from module `imem' to a netlist network with 32 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =      80  lev =    7 (5.19)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =      72  lev =    6 (3.72)  mem = 0.00 MB  ch =   13  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      72.  Ch =    12.  Total mem =    0.02 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 3990.00.  Ar =      34.0.  Edge =      117.  Cut =      405.  T =     0.00 sec
ABC: P:  Del = 3990.00.  Ar =      34.0.  Edge =      118.  Cut =      399.  T =     0.00 sec
ABC: P:  Del = 3990.00.  Ar =      35.0.  Edge =      124.  Cut =      404.  T =     0.00 sec
ABC: F:  Del = 3990.00.  Ar =      30.0.  Edge =      107.  Cut =      266.  T =     0.00 sec
ABC: A:  Del = 3990.00.  Ar =      29.0.  Edge =       99.  Cut =      271.  T =     0.00 sec
ABC: A:  Del = 3990.00.  Ar =      29.0.  Edge =       99.  Cut =      271.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =      98  lev =    6 (3.81)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     29  edge =      99  lev =    2 (1.97)  mem = 0.00 MB
ABC: LUT = 29 : 2=5 17.2 %  3=7 24.1 %  4=17 58.6 %  Ave = 3.41
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~136 debug messages>
Removed 128 unused cells and 178 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       29
ABC RESULTS:           input signals:        1
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~485 debug messages>
Extracted 2924 AND gates and 7354 wires from module `regfile' to a netlist network with 558 inputs and 79 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    2924  lev =   10 (8.67)  mem = 0.04 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    5817  lev =    9 (7.86)  mem = 0.08 MB  ch =  734  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =    5817.  Ch =   642.  Total mem =    0.89 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 8245.00.  Ar =    1112.0.  Edge =     3921.  Cut =    24424.  T =     0.00 sec
ABC: P:  Del = 8245.00.  Ar =    1049.0.  Edge =     3732.  Cut =    23586.  T =     0.00 sec
ABC: P:  Del = 8245.00.  Ar =     987.0.  Edge =     3407.  Cut =    24965.  T =     0.00 sec
ABC: F:  Del = 8245.00.  Ar =     985.0.  Edge =     3401.  Cut =    20569.  T =     0.00 sec
ABC: A:  Del = 8245.00.  Ar =     985.0.  Edge =     3361.  Cut =    19851.  T =     0.00 sec
ABC: A:  Del = 8245.00.  Ar =     985.0.  Edge =     3361.  Cut =    19773.  T =     0.00 sec
ABC: Total time =     0.01 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    2824  lev =    9 (7.86)  mem = 0.04 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =    985  edge =    3361  lev =    4 (3.62)  mem = 0.03 MB
ABC: LUT = 985 : 2=106 10.8 %  3=367 37.3 %  4=512 52.0 %  Ave = 3.41
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.11 seconds, total: 0.11 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~1283 debug messages>
Removed 4507 unused cells and 5144 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:      985
ABC RESULTS:           input signals:       22
ABC RESULTS:          output signals:       17
Removing temp directory.

16.38.17. Executing TECHMAP pass (map to technology primitives).

16.38.17.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_unmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_unmap.v' to AST representation.
Generating RTLIL representation for module `\$__DFF_x__$abc9_flop'.
Generating RTLIL representation for module `\$__ABC9_SCC_BREAKER'.
Successfully finished Verilog frontend.

16.38.17.2. Continuing TECHMAP pass.
Using template $paramod$ba68a0420314c29d51ab7ddbd2ec9361aa29f018\SB_RAM40_4K for cells of type $paramod$ba68a0420314c29d51ab7ddbd2ec9361aa29f018\SB_RAM40_4K.
Using template $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 for cells of type $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1.
Using template SB_DFFR_$abc9_byp for cells of type SB_DFFR_$abc9_byp.
Using template SB_DFFER_$abc9_byp for cells of type SB_DFFER_$abc9_byp.
No more expansions possible.
<suppressed ~108 debug messages>

16.39. Executing ICE40_WRAPCARRY pass (wrap carries).

16.40. Executing TECHMAP pass (map to technology primitives).

16.40.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

16.40.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~22 debug messages>
Removed 123 unused cells and 12121 unused wires.

16.41. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31

Eliminating LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31

Combining LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31

Eliminating LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31

Combining LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        5
  2-LUT                4
  3-LUT                1
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        5
  2-LUT                4
  3-LUT                1
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        5
  2-LUT                4
  3-LUT                1
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       14
  2-LUT                3
  3-LUT                5
  4-LUT                6
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       14
  2-LUT                3
  3-LUT                5
  4-LUT                6
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       14
  2-LUT                3
  3-LUT                5
  4-LUT                6
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       14
  2-LUT                2
  3-LUT                8
  4-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       14
  2-LUT                2
  3-LUT                8
  4-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       14
  2-LUT                2
  3-LUT                8
  4-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       30
  2-LUT                5
  3-LUT                7
  4-LUT               18
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       30
  2-LUT                5
  3-LUT                7
  4-LUT               18
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       30
  2-LUT                5
  3-LUT                7
  4-LUT               18
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:      985
  2-LUT              106
  3-LUT              367
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:      985
  2-LUT              106
  3-LUT              367
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:      985
  2-LUT              106
  3-LUT              367
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminated 0 LUTs.
Combined 0 LUTs.
<suppressed ~9799 debug messages>

16.42. Executing TECHMAP pass (map to technology primitives).

16.42.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

16.42.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10100010 for cells of type $lut.
Using template $paramod$4b9b235bc4444ff899bef0c648e4109b26737f1a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00101010 for cells of type $lut.
Using template $paramod$e5758a88c2c156ccb3037f71a73d1b15af5b310d\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10000000 for cells of type $lut.
Using template $paramod$b9305c669fd883d24574655b402c7ff9f28efb1a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0010 for cells of type $lut.
Using template $paramod$0ee0167fb5dd83bdfe7197fff23e2c7146c57037\$lut for cells of type $lut.
Using template $paramod$75d5c453cca75cc7a7ca320c4fb7be0932b6aaa7\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00000001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00100111 for cells of type $lut.
Using template $paramod$e2d96f36ef28053ecd27167cd95b944485ac3146\$lut for cells of type $lut.
Using template $paramod$305fd3b7552c2378a7cd8315d4f432697caa28ea\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10001010 for cells of type $lut.
Using template $paramod$efc60783c939ae41b2f3555af407b17c007b27f8\$lut for cells of type $lut.
Using template $paramod$58df2c605746858c7e53492c8f57d6f1fafa12d2\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01010100 for cells of type $lut.
Using template $paramod$18455d4fd1270af2266bf4bb1c44971b2eb6b37a\$lut for cells of type $lut.
Using template $paramod$b28b4ecbaa07efdcc51c93348ccdc2395f8b41c1\$lut for cells of type $lut.
Using template $paramod$c7754eeb17b54dfe53ea4a973db3714d78ced2f9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11011000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0100 for cells of type $lut.
Using template $paramod$c8f16510db975553c8b0be1064e8f5234175f8a8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11100100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00011011 for cells of type $lut.
Using template $paramod$16894c241be5ea1f024e9339dea788b4dbe184ae\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10101000 for cells of type $lut.
Using template $paramod$79364b9974cfc81fb54c164d10340bf9c7bccd7f\$lut for cells of type $lut.
Using template $paramod$3702268f692b8bf258e428f65d3bca4e1f76d98b\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00010000 for cells of type $lut.
Using template $paramod$2e48109de5f7f59aba314a57c42c7f686faa334a\$lut for cells of type $lut.
Using template $paramod$c97e738df958f490eb8461efe944668c310ecac5\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10101011 for cells of type $lut.
Using template $paramod$edfe6773e2ae95f1f17ad5bea62c0e1b079fa667\$lut for cells of type $lut.
Using template $paramod$37cbd66b1bb96fdf033ea86280ae98f0988c69d1\$lut for cells of type $lut.
Using template $paramod$179bbca2dd7fa841ad12e8b0327ef61d6e9a7bc3\$lut for cells of type $lut.
Using template $paramod$df2c5671757930949ccad092458a7f705f78ea6a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0001 for cells of type $lut.
Using template $paramod$c28a8b7ce0535d090c4cfb52e9c74affd52b110c\$lut for cells of type $lut.
Using template $paramod$8e44661def013b6bf9fe6f8b049ef2c838d749f9\$lut for cells of type $lut.
Using template $paramod$d9e869de4ea8677851dc452d380224cee441f821\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10111010 for cells of type $lut.
Using template $paramod$65638f8febbdd45770f403709fe5a3c8c1481fab\$lut for cells of type $lut.
Using template $paramod$4834046533425f54583d6bd31e49deb63455e1a5\$lut for cells of type $lut.
Using template $paramod$bb8deb0924e1d1ccbc1490573420a052418cb1bd\$lut for cells of type $lut.
Using template $paramod$31f0a66a4b242b524303bfb4ac95c05ad74158f8\$lut for cells of type $lut.
Using template $paramod$c63fb63be97a9db4ce7bd031e26652a8b349a094\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00111001 for cells of type $lut.
Using template $paramod$43f80bfa85ab470887310b168a5d80144489e087\$lut for cells of type $lut.
Using template $paramod$f9b715fbf1040e81e900b2461c2390d17ed5e988\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00110111 for cells of type $lut.
Using template $paramod$8abe7c158d2b6dbbc90320b2d54f64112beb654e\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11001101 for cells of type $lut.
Using template $paramod$70f68cc10fbeada9b6fa90c3bb75475e348ca467\$lut for cells of type $lut.
Using template $paramod$40e5a5bffee68d424d8b966d83c16c547cdeb8ab\$lut for cells of type $lut.
Using template $paramod$ed53936884d8f0c77515f02c43ecf1f4f086a1bf\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0110 for cells of type $lut.
Using template $paramod$8d7a8d6e3356de09670738ba85f2c6b874f6b06d\$lut for cells of type $lut.
Using template $paramod$5c7d886f3b88971ac55fed4bca034a87bf180f7d\$lut for cells of type $lut.
Using template $paramod$19e5b38cca183d8b6b3a15d20dc995c09cd71893\$lut for cells of type $lut.
Using template $paramod$6d6beead1425af15cf78b27fd9b11b41b5d4bce8\$lut for cells of type $lut.
Using template $paramod$ba7c22fadfbf9ee7abcb895a21403114111dd201\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10000010 for cells of type $lut.
Using template $paramod$7ad6513db21d535b81390e1710eb838751ca64e8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00001001 for cells of type $lut.
Using template $paramod$f9813472aa48e533b3838c6f2316dc2e78c66111\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11100011 for cells of type $lut.
Using template $paramod$571404c0889eaf57f492cb5e37f8acb5df5852f9\$lut for cells of type $lut.
Using template $paramod$2b29ccbd5fb8b9c557f92ddec1023c75686f32ae\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10111110 for cells of type $lut.
Using template $paramod$84954618eb9fde76ec37ab04fd2c5afa124986a3\$lut for cells of type $lut.
Using template $paramod$41326ad8644342a66dfb051d050f2b6fbf15015b\$lut for cells of type $lut.
Using template $paramod$eb3d85023a8c03ed866055b7b6ffb27450652855\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00000100 for cells of type $lut.
Using template $paramod$32abbd1d449a67fb913b4733374e345d4c17175b\$lut for cells of type $lut.
Using template $paramod$01c608da0c772a10858492e8ba4f65bc04f42266\$lut for cells of type $lut.
Using template $paramod$bf60f6ec407ee294958b6566514fc3125ec42258\$lut for cells of type $lut.
Using template $paramod$096a408fd37568b92eea484c5cc9a8e86ab67a87\$lut for cells of type $lut.
Using template $paramod$fca001e3e0b52158a872e76e56c01ec10dfbb1de\$lut for cells of type $lut.
Using template $paramod$2ff1ef2fa67138cf71814804285c211c9e377fda\$lut for cells of type $lut.
Using template $paramod$e51a8a571bee774247b38f52d6e85fd62ae52cea\$lut for cells of type $lut.
Using template $paramod$dcba541ad53a9873d71bfba6c13dc2a8e2a60a79\$lut for cells of type $lut.
Using template $paramod$b93d1ea7a612a32c185108f67a153d44ffb9aac2\$lut for cells of type $lut.
Using template $paramod$5e9374f44a27c3f8a1c38af244ec43ceb4fb8d4f\$lut for cells of type $lut.
Using template $paramod$3ccd4e460eeb40194aa88ef0e5239278bde42035\$lut for cells of type $lut.
Using template $paramod$1843b3c15f2447d117e2d5de9b00f791ef5f9fa3\$lut for cells of type $lut.
Using template $paramod$dcfc23e7d6bcd26b82233688fdfbe92480ddfdcf\$lut for cells of type $lut.
Using template $paramod$fd904e9e35cfd343a9df248824bd3f1408724879\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11011100 for cells of type $lut.
Using template $paramod$658b9ed803f0d3d335616d3858b53e0a2522f1e8\$lut for cells of type $lut.
Using template $paramod$6e238df02989b317f10820a22773676e71120644\$lut for cells of type $lut.
No more expansions possible.
<suppressed ~2580 debug messages>
Removed 0 unused cells and 3213 unused wires.

16.43. Executing AUTONAME pass.
Renamed 156 objects in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000 (4 iterations).
Renamed 2 objects in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 (2 iterations).
Renamed 32 objects in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000 (2 iterations).
Renamed 4 objects in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100 (2 iterations).
Renamed 32 objects in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000 (2 iterations).
Renamed 811 objects in module alu (9 iterations).
Renamed 191 objects in module condcheck (15 iterations).
Renamed 5 objects in module condlogic (2 iterations).
Renamed 22 objects in module decoder (4 iterations).
Renamed 275 objects in module dmem (13 iterations).
Renamed 26 objects in module extend (2 iterations).
Renamed 85 objects in module imem (8 iterations).
Renamed 5702 objects in module regfile (13 iterations).
<suppressed ~2447 debug messages>

16.44. Executing HIERARCHY pass (managing design hierarchy).

16.44.1. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \arm
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Used module:         \datapath
Used module:             \alu
Used module:             \extend
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             \regfile
Used module:     \dmem
Used module:     \imem

16.44.2. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \arm
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Used module:         \datapath
Used module:             \alu
Used module:             \extend
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             \regfile
Used module:     \dmem
Used module:     \imem
Removed 0 unused modules.

16.45. Printing statistics.

=== $paramod\adder\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                 34
   Number of wire bits:            127
   Number of public wires:          34
   Number of public wire bits:     127
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 63
     SB_CARRY                       31
     SB_LUT4                        32

=== $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 ===

   Number of wires:                  5
   Number of wire bits:              7
   Number of public wires:           5
   Number of public wire bits:       7
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     SB_DFFER                        2

=== $paramod\flopr\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                  4
   Number of wire bits:             66
   Number of public wires:           4
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 32
     SB_DFFR                        32

=== $paramod\mux2\WIDTH=s32'00000000000000000000000000000100 ===

   Number of wires:                  4
   Number of wire bits:             13
   Number of public wires:           4
   Number of public wire bits:      13
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     SB_LUT4                         4

=== $paramod\mux2\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                  4
   Number of wire bits:             97
   Number of public wires:           4
   Number of public wire bits:      97
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 32
     SB_LUT4                        32

=== alu ===

   Number of wires:                107
   Number of wire bits:            374
   Number of public wires:         107
   Number of public wire bits:     374
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                171
     SB_CARRY                       32
     SB_LUT4                       139

=== arm ===

   Number of wires:                 16
   Number of wire bits:            177
   Number of public wires:          16
   Number of public wire bits:     177
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     controller                      1
     datapath                        1

=== condcheck ===

   Number of wires:                 16
   Number of wire bits:             46
   Number of public wires:          16
   Number of public wire bits:      46
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 22
     SB_LUT4                        22

=== condlogic ===

   Number of wires:                 15
   Number of wire bits:             26
   Number of public wires:          15
   Number of public wire bits:      26
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010      2
     SB_LUT4                         5
     condcheck                       1

=== controller ===

   Number of wires:                 17
   Number of wire bits:             43
   Number of public wires:          17
   Number of public wire bits:      43
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     condlogic                       1
     decoder                         1

=== cpu_main ===

   Number of wires:                  9
   Number of wire bits:            164
   Number of public wires:           9
   Number of public wire bits:     164
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  3
     arm                             1
     dmem                            1
     imem                            1

=== datapath ===

   Number of wires:                 24
   Number of wire bits:            408
   Number of public wires:          24
   Number of public wire bits:     408
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 11
     $paramod\adder\WIDTH=s32'00000000000000000000000000100000      2
     $paramod\flopr\WIDTH=s32'00000000000000000000000000100000      1
     $paramod\mux2\WIDTH=s32'00000000000000000000000000000100      2
     $paramod\mux2\WIDTH=s32'00000000000000000000000000100000      3
     alu                             1
     extend                          1
     regfile                         1

=== decoder ===

   Number of wires:                 18
   Number of wire bits:             47
   Number of public wires:          18
   Number of public wire bits:      47
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 14
     SB_LUT4                        14

=== dmem ===

   Number of wires:                 28
   Number of wire bits:            141
   Number of public wires:          28
   Number of public wire bits:     141
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 39
     SB_DFF                         24
     SB_LUT4                        14
     SB_RAM40_4K                     1

=== extend ===

   Number of wires:                  3
   Number of wire bits:             58
   Number of public wires:           3
   Number of public wire bits:      58
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 26
     SB_LUT4                        26

=== imem ===

   Number of wires:                 11
   Number of wire bits:             93
   Number of public wires:          11
   Number of public wire bits:      93
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 30
     SB_LUT4                        30

=== regfile ===

   Number of wires:                393
   Number of wire bits:           1958
   Number of public wires:         393
   Number of public wire bits:    1958
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1465
     SB_DFFE                       480
     SB_LUT4                       985

=== design hierarchy ===

   cpu_main                          1
     arm                             1
       controller                    1
         condlogic                   1
           $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010      2
           condcheck                 1
         decoder                     1
       datapath                      1
         $paramod\adder\WIDTH=s32'00000000000000000000000000100000      2
         $paramod\flopr\WIDTH=s32'00000000000000000000000000100000      1
         $paramod\mux2\WIDTH=s32'00000000000000000000000000000100      2
         $paramod\mux2\WIDTH=s32'00000000000000000000000000100000      3
         alu                         1
         extend                      1
         regfile                     1
     dmem                            1
     imem                            1

   Number of wires:                759
   Number of wire bits:           4186
   Number of public wires:         759
   Number of public wire bits:    4186
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               2038
     SB_CARRY                       94
     SB_DFF                         24
     SB_DFFE                       480
     SB_DFFER                        4
     SB_DFFR                        32
     SB_LUT4                      1403
     SB_RAM40_4K                     1

16.46. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\adder\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010...
Checking module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000...
Checking module alu...
Checking module arm...
Checking module condcheck...
Checking module condlogic...
Checking module controller...
Checking module cpu_main...
Checking module datapath...
Checking module decoder...
Checking module dmem...
Checking module extend...
Checking module imem...
Checking module regfile...
Found and reported 0 problems.

End of script. Logfile hash: 9aa02fdde5, CPU: user 2.02s system 0.05s
Yosys 0.19+36 (git sha1 30a4218f5, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 24% 17x abc9_exe (0 sec), 18% 11x techmap (0 sec), ...
