
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.19+36 (git sha1 30a4218f5, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Running command `verilog_defines  -DNO_ICE40_DEFAULT_ASSIGNMENTS ; read_verilog -Irtl -sv rtl/adder.sv rtl/alu.sv rtl/arm.sv rtl/condlogic.sv rtl/controller.sv rtl/cpu_main.sv rtl/datapath.sv rtl/decoder.sv rtl/dmem.sv rtl/extend.sv rtl/flopenr.sv rtl/flopr.sv rtl/imem.sv rtl/mux2.sv rtl/regfile.sv ; synth_ice40 -device u -abc9 -noflatten' --

1. Executing Verilog-2005 frontend: rtl/adder.sv
Parsing SystemVerilog input from `rtl/adder.sv' to AST representation.
Generating RTLIL representation for module `\adder'.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend: rtl/alu.sv
Parsing SystemVerilog input from `rtl/alu.sv' to AST representation.
Generating RTLIL representation for module `\alu'.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend: rtl/arm.sv
Parsing SystemVerilog input from `rtl/arm.sv' to AST representation.
Generating RTLIL representation for module `\arm'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend: rtl/condlogic.sv
Parsing SystemVerilog input from `rtl/condlogic.sv' to AST representation.
Generating RTLIL representation for module `\condlogic'.
Generating RTLIL representation for module `\condcheck'.
Successfully finished Verilog frontend.

5. Executing Verilog-2005 frontend: rtl/controller.sv
Parsing SystemVerilog input from `rtl/controller.sv' to AST representation.
Generating RTLIL representation for module `\controller'.
Successfully finished Verilog frontend.

6. Executing Verilog-2005 frontend: rtl/cpu_main.sv
Parsing SystemVerilog input from `rtl/cpu_main.sv' to AST representation.
Generating RTLIL representation for module `\cpu_main'.
Successfully finished Verilog frontend.

7. Executing Verilog-2005 frontend: rtl/datapath.sv
Parsing SystemVerilog input from `rtl/datapath.sv' to AST representation.
Generating RTLIL representation for module `\datapath'.
Successfully finished Verilog frontend.

8. Executing Verilog-2005 frontend: rtl/decoder.sv
Parsing SystemVerilog input from `rtl/decoder.sv' to AST representation.
Generating RTLIL representation for module `\decoder'.
Successfully finished Verilog frontend.

9. Executing Verilog-2005 frontend: rtl/dmem.sv
Parsing SystemVerilog input from `rtl/dmem.sv' to AST representation.
Generating RTLIL representation for module `\dmem'.
Successfully finished Verilog frontend.

10. Executing Verilog-2005 frontend: rtl/extend.sv
Parsing SystemVerilog input from `rtl/extend.sv' to AST representation.
Generating RTLIL representation for module `\extend'.
Successfully finished Verilog frontend.

11. Executing Verilog-2005 frontend: rtl/flopenr.sv
Parsing SystemVerilog input from `rtl/flopenr.sv' to AST representation.
Generating RTLIL representation for module `\flopenr'.
Successfully finished Verilog frontend.

12. Executing Verilog-2005 frontend: rtl/flopr.sv
Parsing SystemVerilog input from `rtl/flopr.sv' to AST representation.
Generating RTLIL representation for module `\flopr'.
Successfully finished Verilog frontend.

13. Executing Verilog-2005 frontend: rtl/imem.sv
Parsing SystemVerilog input from `rtl/imem.sv' to AST representation.
Generating RTLIL representation for module `\imem'.
Successfully finished Verilog frontend.

14. Executing Verilog-2005 frontend: rtl/mux2.sv
Parsing SystemVerilog input from `rtl/mux2.sv' to AST representation.
Generating RTLIL representation for module `\mux2'.
Successfully finished Verilog frontend.

15. Executing Verilog-2005 frontend: rtl/regfile.sv
Parsing SystemVerilog input from `rtl/regfile.sv' to AST representation.
Generating RTLIL representation for module `\regfile'.
Successfully finished Verilog frontend.

16. Executing SYNTH_ICE40 pass.

16.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Generating RTLIL representation for module `\ICESTORM_RAM'.
Successfully finished Verilog frontend.

16.2. Executing HIERARCHY pass (managing design hierarchy).

16.2.1. Finding top of design hierarchy..
root of   0 design levels: regfile             
root of   0 design levels: mux2                
root of   0 design levels: imem                
root of   0 design levels: flopr               
root of   0 design levels: flopenr             
root of   0 design levels: extend              
root of   0 design levels: dmem                
root of   0 design levels: decoder             
root of   1 design levels: datapath            
root of   4 design levels: cpu_main            
root of   2 design levels: controller          
root of   0 design levels: condcheck           
root of   1 design levels: condlogic           
root of   3 design levels: arm                 
root of   0 design levels: alu                 
root of   0 design levels: adder               
Automatically selected cpu_main as design top module.

16.2.2. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             \mux2
Used module:             \extend
Used module:             \regfile
Used module:             \adder
Used module:             \flopr
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 \flopenr
Used module:             \decoder
Parameter 1 (\WIDTH) = 32

16.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\mux2'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 4

16.2.4. Executing AST frontend in derive mode using pre-parsed AST for module `\mux2'.
Parameter 1 (\WIDTH) = 4
Generating RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Parameter 1 (\WIDTH) = 4
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Parameter 1 (\WIDTH) = 32

16.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\adder'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32

16.2.6. Executing AST frontend in derive mode using pre-parsed AST for module `\flopr'.
Parameter 1 (\WIDTH) = 32
Generating RTLIL representation for module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 32
Found cached RTLIL representation for module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Parameter 1 (\WIDTH) = 2

16.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\flopenr'.
Parameter 1 (\WIDTH) = 2
Generating RTLIL representation for module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Parameter 1 (\WIDTH) = 2
Found cached RTLIL representation for module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.

16.2.8. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             \extend
Used module:             \regfile
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder

16.2.9. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \dmem
Used module:     \imem
Used module:     \arm
Used module:         \datapath
Used module:             \alu
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             \extend
Used module:             \regfile
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Removing unused module `\mux2'.
Removing unused module `\flopr'.
Removing unused module `\flopenr'.
Removing unused module `\adder'.
Removed 4 unused modules.
Mapping positional arguments of cell datapath.alu (alu).
Mapping positional arguments of cell datapath.srcbmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.ext (extend).
Mapping positional arguments of cell datapath.resmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.rf (regfile).
Mapping positional arguments of cell datapath.ra2mux ($paramod\mux2\WIDTH=s32'00000000000000000000000000000100).
Mapping positional arguments of cell datapath.ra1mux ($paramod\mux2\WIDTH=s32'00000000000000000000000000000100).
Mapping positional arguments of cell datapath.pcadd2 ($paramod\adder\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcadd1 ($paramod\adder\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcreg ($paramod\flopr\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell datapath.pcmux ($paramod\mux2\WIDTH=s32'00000000000000000000000000100000).
Mapping positional arguments of cell cpu_main.dmem (dmem).
Mapping positional arguments of cell cpu_main.imem (imem).
Mapping positional arguments of cell cpu_main.arm (arm).
Mapping positional arguments of cell controller.cl (condlogic).
Mapping positional arguments of cell controller.dec (decoder).
Mapping positional arguments of cell condlogic.cc (condcheck).
Mapping positional arguments of cell condlogic.flagreg0 ($paramod\flopenr\WIDTH=s32'00000000000000000000000000000010).
Mapping positional arguments of cell condlogic.flagreg1 ($paramod\flopenr\WIDTH=s32'00000000000000000000000000000010).
Mapping positional arguments of cell arm.dp (datapath).
Mapping positional arguments of cell arm.c (controller).

16.3. Executing PROC pass (convert processes to netlists).

16.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361 in module SB_DFFNES.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$356 in module SB_DFFNESS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352 in module SB_DFFNER.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$347 in module SB_DFFNESR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$344 in module SB_DFFNS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$341 in module SB_DFFNSS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$338 in module SB_DFFNR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$335 in module SB_DFFNSR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327 in module SB_DFFES.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$322 in module SB_DFFESS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318 in module SB_DFFER.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$313 in module SB_DFFESR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$310 in module SB_DFFS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$307 in module SB_DFFSS.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$304 in module SB_DFFR.
Marked 1 switch rules as full_case in process $proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$301 in module SB_DFFSR.
Marked 1 switch rules as full_case in process $proc$rtl/regfile.sv:15$109 in module regfile.
Marked 1 switch rules as full_case in process $proc$rtl/flopenr.sv:6$505 in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Marked 1 switch rules as full_case in process $proc$rtl/flopr.sv:5$504 in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Marked 1 switch rules as full_case in process $proc$rtl/extend.sv:0$57 in module extend.
Marked 1 switch rules as full_case in process $proc$rtl/dmem.sv:13$50 in module dmem.
Marked 2 switch rules as full_case in process $proc$rtl/decoder.sv:0$40 in module decoder.
Marked 3 switch rules as full_case in process $proc$rtl/decoder.sv:0$39 in module decoder.
Marked 1 switch rules as full_case in process $proc$rtl/condlogic.sv:0$23 in module condcheck.
Removed 1 dead cases from process $proc$rtl/alu.sv:0$15 in module alu.
Marked 1 switch rules as full_case in process $proc$rtl/alu.sv:0$15 in module alu.
Removed a total of 1 dead cases.

16.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 9 redundant assignments.
Promoted 49 assignments to connections.

16.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$364'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$360'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$355'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$351'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$346'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$332'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$330'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$326'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$321'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$317'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$312'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$309'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$306'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$303'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$300'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$298'.
  Set init value: \Q = 1'0

16.3.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \S in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361'.
Found async reset \R in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352'.
Found async reset \S in `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$344'.
Found async reset \R in `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$338'.
Found async reset \S in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327'.
Found async reset \R in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318'.
Found async reset \S in `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$310'.
Found async reset \R in `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$304'.
Found async reset \reset in `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$505'.
Found async reset \reset in `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$504'.

16.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~29 debug messages>

16.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$364'.
Creating decoders for process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$360'.
Creating decoders for process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$356'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$355'.
Creating decoders for process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$351'.
Creating decoders for process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$347'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$346'.
Creating decoders for process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$344'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
Creating decoders for process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$341'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
Creating decoders for process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$338'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
Creating decoders for process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$335'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
Creating decoders for process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$333'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$332'.
Creating decoders for process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$331'.
Creating decoders for process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$330'.
Creating decoders for process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$326'.
Creating decoders for process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$322'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$321'.
Creating decoders for process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$317'.
Creating decoders for process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$313'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$312'.
Creating decoders for process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$310'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$309'.
Creating decoders for process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$307'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$306'.
Creating decoders for process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$304'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$303'.
Creating decoders for process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$301'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$300'.
Creating decoders for process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$299'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$298'.
Creating decoders for process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$297'.
Creating decoders for process `\regfile.$proc$rtl/regfile.sv:15$109'.
     1/3: $1$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$115
     2/3: $1$memwr$\rf$rtl/regfile.sv:16$108_DATA[31:0]$114
     3/3: $1$memwr$\rf$rtl/regfile.sv:16$108_ADDR[3:0]$113
Creating decoders for process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$505'.
     1/1: $0\q[1:0]
Creating decoders for process `\imem.$proc$rtl/imem.sv:0$91'.
Creating decoders for process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$504'.
     1/1: $0\q[31:0]
Creating decoders for process `\extend.$proc$rtl/extend.sv:0$57'.
     1/1: $1\ExtImm[31:0]
Creating decoders for process `\dmem.$proc$rtl/dmem.sv:13$50'.
     1/3: $1$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$56
     2/3: $1$memwr$\RAM$rtl/dmem.sv:14$48_DATA[31:0]$55
     3/3: $1$memwr$\RAM$rtl/dmem.sv:14$48_ADDR[31:0]$54
Creating decoders for process `\decoder.$proc$rtl/decoder.sv:0$40'.
     1/4: $1\FlagW[1:0] [1]
     2/4: $2\ALUControl[1:0]
     3/4: $1\FlagW[1:0] [0]
     4/4: $1\ALUControl[1:0]
Creating decoders for process `\decoder.$proc$rtl/decoder.sv:0$39'.
     1/3: $3\controls[9:0]
     2/3: $2\controls[9:0]
     3/3: $1\controls[9:0]
Creating decoders for process `\condcheck.$proc$rtl/condlogic.sv:0$23'.
     1/1: $1\CondEx[0:0]
Creating decoders for process `\alu.$proc$rtl/alu.sv:0$15'.
     1/1: $1\ALUResult[31:0]

16.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:10$60_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:11$61_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:12$62_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:13$63_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:14$64_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:15$65_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:16$66_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:17$67_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:18$68_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:19$69_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:20$70_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:21$71_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:22$72_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:23$73_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\imem.$memwr$\RAM$rtl/imem.sv:24$74_EN' from process `\imem.$proc$rtl/imem.sv:0$91'.
No latch inferred for signal `\extend.\ExtImm' from process `\extend.$proc$rtl/extend.sv:0$57'.
No latch inferred for signal `\decoder.\ALUControl' from process `\decoder.$proc$rtl/decoder.sv:0$40'.
No latch inferred for signal `\decoder.\FlagW' from process `\decoder.$proc$rtl/decoder.sv:0$40'.
No latch inferred for signal `\decoder.\controls' from process `\decoder.$proc$rtl/decoder.sv:0$39'.
No latch inferred for signal `\condcheck.\CondEx' from process `\condcheck.$proc$rtl/condlogic.sv:0$23'.
No latch inferred for signal `\alu.\ALUResult' from process `\alu.$proc$rtl/alu.sv:0$15'.

16.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\SB_DFFNES.\Q' using process `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361'.
  created $adff cell `$procdff$634' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESS.\Q' using process `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$356'.
  created $dff cell `$procdff$635' with negative edge clock.
Creating register for signal `\SB_DFFNER.\Q' using process `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352'.
  created $adff cell `$procdff$636' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESR.\Q' using process `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$347'.
  created $dff cell `$procdff$637' with negative edge clock.
Creating register for signal `\SB_DFFNS.\Q' using process `\SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$344'.
  created $adff cell `$procdff$638' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSS.\Q' using process `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$341'.
  created $dff cell `$procdff$639' with negative edge clock.
Creating register for signal `\SB_DFFNR.\Q' using process `\SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$338'.
  created $adff cell `$procdff$640' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSR.\Q' using process `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$335'.
  created $dff cell `$procdff$641' with negative edge clock.
Creating register for signal `\SB_DFFNE.\Q' using process `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$333'.
  created $dff cell `$procdff$642' with negative edge clock.
Creating register for signal `\SB_DFFN.\Q' using process `\SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$331'.
  created $dff cell `$procdff$643' with negative edge clock.
Creating register for signal `\SB_DFFES.\Q' using process `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327'.
  created $adff cell `$procdff$644' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESS.\Q' using process `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$322'.
  created $dff cell `$procdff$645' with positive edge clock.
Creating register for signal `\SB_DFFER.\Q' using process `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318'.
  created $adff cell `$procdff$646' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESR.\Q' using process `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$313'.
  created $dff cell `$procdff$647' with positive edge clock.
Creating register for signal `\SB_DFFS.\Q' using process `\SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$310'.
  created $adff cell `$procdff$648' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSS.\Q' using process `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$307'.
  created $dff cell `$procdff$649' with positive edge clock.
Creating register for signal `\SB_DFFR.\Q' using process `\SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$304'.
  created $adff cell `$procdff$650' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSR.\Q' using process `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$301'.
  created $dff cell `$procdff$651' with positive edge clock.
Creating register for signal `\SB_DFFE.\Q' using process `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$299'.
  created $dff cell `$procdff$652' with positive edge clock.
Creating register for signal `\SB_DFF.\Q' using process `\SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$297'.
  created $dff cell `$procdff$653' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$108_ADDR' using process `\regfile.$proc$rtl/regfile.sv:15$109'.
  created $dff cell `$procdff$654' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$108_DATA' using process `\regfile.$proc$rtl/regfile.sv:15$109'.
  created $dff cell `$procdff$655' with positive edge clock.
Creating register for signal `\regfile.$memwr$\rf$rtl/regfile.sv:16$108_EN' using process `\regfile.$proc$rtl/regfile.sv:15$109'.
  created $dff cell `$procdff$656' with positive edge clock.
Creating register for signal `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.\q' using process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$505'.
  created $adff cell `$procdff$657' with positive edge clock and positive level reset.
Creating register for signal `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.\q' using process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$504'.
  created $adff cell `$procdff$658' with positive edge clock and positive level reset.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:14$48_ADDR' using process `\dmem.$proc$rtl/dmem.sv:13$50'.
  created $dff cell `$procdff$659' with positive edge clock.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:14$48_DATA' using process `\dmem.$proc$rtl/dmem.sv:13$50'.
  created $dff cell `$procdff$660' with positive edge clock.
Creating register for signal `\dmem.$memwr$\RAM$rtl/dmem.sv:14$48_EN' using process `\dmem.$proc$rtl/dmem.sv:13$50'.
  created $dff cell `$procdff$661' with positive edge clock.

16.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

16.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$364'.
Found and cleaned up 1 empty switch in `\SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361'.
Removing empty process `SB_DFFNES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1386$361'.
Removing empty process `SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$360'.
Found and cleaned up 2 empty switches in `\SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$356'.
Removing empty process `SB_DFFNESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1328$356'.
Removing empty process `SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$355'.
Found and cleaned up 1 empty switch in `\SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352'.
Removing empty process `SB_DFFNER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1251$352'.
Removing empty process `SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$351'.
Found and cleaned up 2 empty switches in `\SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$347'.
Removing empty process `SB_DFFNESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1193$347'.
Removing empty process `SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$346'.
Removing empty process `SB_DFFNS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1122$344'.
Removing empty process `SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$343'.
Found and cleaned up 1 empty switch in `\SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$341'.
Removing empty process `SB_DFFNSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1072$341'.
Removing empty process `SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$340'.
Removing empty process `SB_DFFNR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:1001$338'.
Removing empty process `SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$337'.
Found and cleaned up 1 empty switch in `\SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$335'.
Removing empty process `SB_DFFNSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:951$335'.
Removing empty process `SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$334'.
Found and cleaned up 1 empty switch in `\SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$333'.
Removing empty process `SB_DFFNE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:906$333'.
Removing empty process `SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$332'.
Removing empty process `SB_DFFN.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:868$331'.
Removing empty process `SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$330'.
Found and cleaned up 1 empty switch in `\SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327'.
Removing empty process `SB_DFFES.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:789$327'.
Removing empty process `SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$326'.
Found and cleaned up 2 empty switches in `\SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$322'.
Removing empty process `SB_DFFESS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:731$322'.
Removing empty process `SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$321'.
Found and cleaned up 1 empty switch in `\SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318'.
Removing empty process `SB_DFFER.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:654$318'.
Removing empty process `SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$317'.
Found and cleaned up 2 empty switches in `\SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$313'.
Removing empty process `SB_DFFESR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:596$313'.
Removing empty process `SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$312'.
Removing empty process `SB_DFFS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:525$310'.
Removing empty process `SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$309'.
Found and cleaned up 1 empty switch in `\SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$307'.
Removing empty process `SB_DFFSS.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:475$307'.
Removing empty process `SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$306'.
Removing empty process `SB_DFFR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:404$304'.
Removing empty process `SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$303'.
Found and cleaned up 1 empty switch in `\SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$301'.
Removing empty process `SB_DFFSR.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:354$301'.
Removing empty process `SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$300'.
Found and cleaned up 1 empty switch in `\SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$299'.
Removing empty process `SB_DFFE.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:309$299'.
Removing empty process `SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:0$298'.
Removing empty process `SB_DFF.$proc$/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_sim.v:271$297'.
Found and cleaned up 1 empty switch in `\regfile.$proc$rtl/regfile.sv:15$109'.
Removing empty process `regfile.$proc$rtl/regfile.sv:15$109'.
Found and cleaned up 1 empty switch in `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$505'.
Removing empty process `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.$proc$rtl/flopenr.sv:6$505'.
Removing empty process `imem.$proc$rtl/imem.sv:0$91'.
Removing empty process `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000.$proc$rtl/flopr.sv:5$504'.
Found and cleaned up 1 empty switch in `\extend.$proc$rtl/extend.sv:0$57'.
Removing empty process `extend.$proc$rtl/extend.sv:0$57'.
Found and cleaned up 1 empty switch in `\dmem.$proc$rtl/dmem.sv:13$50'.
Removing empty process `dmem.$proc$rtl/dmem.sv:13$50'.
Found and cleaned up 2 empty switches in `\decoder.$proc$rtl/decoder.sv:0$40'.
Removing empty process `decoder.$proc$rtl/decoder.sv:0$40'.
Found and cleaned up 3 empty switches in `\decoder.$proc$rtl/decoder.sv:0$39'.
Removing empty process `decoder.$proc$rtl/decoder.sv:0$39'.
Found and cleaned up 1 empty switch in `\condcheck.$proc$rtl/condlogic.sv:0$23'.
Removing empty process `condcheck.$proc$rtl/condlogic.sv:0$23'.
Found and cleaned up 1 empty switch in `\alu.$proc$rtl/alu.sv:0$15'.
Removing empty process `alu.$proc$rtl/alu.sv:0$15'.
Cleaned up 29 empty switches.

16.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module regfile.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module imem.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module extend.
<suppressed ~1 debug messages>
Optimizing module dmem.
Optimizing module decoder.
<suppressed ~4 debug messages>
Optimizing module datapath.
Optimizing module cpu_main.
Optimizing module controller.
Optimizing module condcheck.
<suppressed ~1 debug messages>
Optimizing module condlogic.
Optimizing module arm.
Optimizing module alu.
<suppressed ~2 debug messages>
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.

16.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module regfile.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module imem.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module extend.
Optimizing module dmem.
Optimizing module decoder.
Optimizing module datapath.
Optimizing module cpu_main.
Optimizing module controller.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module arm.
Optimizing module alu.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.

16.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \regfile..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Removed 13 unused cells and 109 unused wires.
<suppressed ~27 debug messages>

16.6. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\adder\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010...
Checking module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000...
Checking module alu...
Checking module arm...
Checking module condcheck...
Checking module condlogic...
Checking module controller...
Checking module cpu_main...
Checking module datapath...
Checking module decoder...
Checking module dmem...
Checking module extend...
Checking module imem...
Checking module regfile...
Found and reported 0 problems.

16.7. Executing OPT pass (performing simple optimizations).

16.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
<suppressed ~18 debug messages>
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
<suppressed ~6 debug messages>
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 8 cells.

16.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$598.
    dead port 2/2 on $mux $procmux$606.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 2 multiplexer ports.
<suppressed ~21 debug messages>

16.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
    Consolidated identical input bits for $mux cell $procmux$567:
      Old ports: A=0, B=32'11111111111111111111111111111111, Y=$0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53
      New ports: A=1'0, B=1'1, Y=$0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0]
      New connections: $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [31:1] = { $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] $0$memwr$\RAM$rtl/dmem.sv:14$48_EN[31:0]$53 [0] }
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
    Consolidated identical input bits for $mux cell $procmux$551:
      Old ports: A=0, B=32'11111111111111111111111111111111, Y=$0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112
      New ports: A=1'0, B=1'1, Y=$0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0]
      New connections: $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [31:1] = { $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] $0$memwr$\rf$rtl/regfile.sv:16$108_EN[31:0]$112 [0] }
  Optimizing cells in module \regfile.
Performed a total of 2 changes.

16.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.7.6. Executing OPT_DFF pass (perform DFF optimizations).

16.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 10 unused wires.
<suppressed ~2 debug messages>

16.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.9. Rerunning OPT passes. (Maybe there is more to do..)

16.7.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

16.7.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.7.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.7.13. Executing OPT_DFF pass (perform DFF optimizations).

16.7.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.7.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.7.16. Finished OPT passes. (There is nothing left to do.)

16.8. Executing FSM pass (extract and optimize FSM).

16.8.1. Executing FSM_DETECT pass (finding FSMs in design).

16.8.2. Executing FSM_EXTRACT pass (extracting FSM from design).

16.8.3. Executing FSM_OPT pass (simple optimizations of FSMs).

16.8.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.8.5. Executing FSM_OPT pass (simple optimizations of FSMs).

16.8.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

16.8.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

16.8.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

16.9. Executing OPT pass (performing simple optimizations).

16.9.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

16.9.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.9.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $procdff$657 ($adff) from module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 (D = \d, Q = \q).

16.9.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

16.9.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.9. Rerunning OPT passes. (Maybe there is more to do..)

16.9.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

16.9.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.9.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.9.13. Executing OPT_DFF pass (perform DFF optimizations).

16.9.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.9.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.9.16. Finished OPT passes. (There is nothing left to do.)

16.10. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$622_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$623_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$624_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell condcheck.$procmux$625_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell condcheck.$procmux$626_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell condcheck.$procmux$627_CMP0 ($eq).
Removed top 3 bits (of 4) from port B of cell condcheck.$procmux$628_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell decoder.$eq$rtl/decoder.sv:45$42 ($eq).
Removed top 2 bits (of 4) from port B of cell decoder.$procmux$583_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell decoder.$procmux$584_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell decoder.$procmux$599_CMP0 ($eq).
Removed top 4 bits (of 10) from mux cell decoder.$procmux$604 ($mux).
Removed top 4 bits (of 10) from wire decoder.$2\controls[9:0].
Removed top 31 address bits (of 32) from memory init port dmem.$auto$proc_memwr.cc:45:proc_memwr$663 (RAM).
Removed top 31 address bits (of 32) from memory read port dmem.$memrd$\RAM$rtl/dmem.sv:11$49 (RAM).
Removed top 31 bits (of 32) from mux cell dmem.$procmux$573 ($mux).
Removed top 31 bits (of 32) from wire dmem.$0$memwr$\RAM$rtl/dmem.sv:14$48_ADDR[31:0]$51.
Removed top 1 bits (of 2) from port B of cell extend.$procmux$564_CMP0 ($eq).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:10$76 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:11$77 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:12$78 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:13$79 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:14$80 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:15$81 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:16$82 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:17$83 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:18$84 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:19$85 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:20$86 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:21$87 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:22$88 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:23$89 (RAM).
Removed top 26 address bits (of 32) from memory init port imem.$meminit$\RAM$rtl/imem.sv:24$90 (RAM).
Removed top 26 address bits (of 32) from memory read port imem.$memrd$\RAM$rtl/imem.sv:28$75 (RAM).

16.11. Executing PEEPOPT pass (run peephole optimizers).

16.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 2 unused wires.
<suppressed ~2 debug messages>

16.13. Executing SHARE pass (SAT-based resource sharing).
Found 2 cells in module regfile that may be considered for resource sharing.
  Analyzing resource sharing options for $memrd$\rf$rtl/regfile.sv:18$120 ($memrd):
    Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:18$119_Y.
    Found 1 candidates: $memrd$\rf$rtl/regfile.sv:17$117
    Analyzing resource sharing with $memrd$\rf$rtl/regfile.sv:17$117 ($memrd):
      Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:17$116_Y.
      Activation pattern for cell $memrd$\rf$rtl/regfile.sv:18$120: $eq$rtl/regfile.sv:18$119_Y = 1'0
      Activation pattern for cell $memrd$\rf$rtl/regfile.sv:17$117: $eq$rtl/regfile.sv:17$116_Y = 1'0
      Size of SAT problem: 0 cells, 41 variables, 97 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: { $eq$rtl/regfile.sv:18$119_Y $eq$rtl/regfile.sv:17$116_Y } = 2'00
  Analyzing resource sharing options for $memrd$\rf$rtl/regfile.sv:17$117 ($memrd):
    Found 1 activation_patterns using ctrl signal $eq$rtl/regfile.sv:17$116_Y.
    No candidates found.

16.14. Executing TECHMAP pass (map to technology primitives).

16.14.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/cmp2lut.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

16.14.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~6 debug messages>

16.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.17. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000:
  creating $macc model for $add$rtl/adder.sv:4$503 ($add).
  creating $alu model for $macc $add$rtl/adder.sv:4$503.
  creating $alu cell for $add$rtl/adder.sv:4$503: $auto$alumacc.cc:485:replace_alu$668
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module alu:
  creating $macc model for $add$rtl/alu.sv:12$4 ($add).
  creating $macc model for $add$rtl/alu.sv:12$5 ($add).
  merging $macc model for $add$rtl/alu.sv:12$4 into $add$rtl/alu.sv:12$5.
  creating $alu model for $macc $add$rtl/alu.sv:12$5.
  creating $alu cell for $add$rtl/alu.sv:12$5: $auto$alumacc.cc:485:replace_alu$671
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arm:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module condcheck:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module condlogic:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module controller:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module cpu_main:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module datapath:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module decoder:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module dmem:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module extend:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module imem:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module regfile:
  created 0 $alu and 0 $macc cells.

16.18. Executing OPT pass (performing simple optimizations).

16.18.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

16.18.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.18.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.6. Executing OPT_DFF pass (perform DFF optimizations).

16.18.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

16.18.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.9. Rerunning OPT passes. (Maybe there is more to do..)

16.18.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

16.18.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.18.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.18.13. Executing OPT_DFF pass (perform DFF optimizations).

16.18.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.18.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.18.16. Finished OPT passes. (There is nothing left to do.)

16.19. Executing MEMORY pass.

16.19.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

16.19.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

16.19.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).
  Analyzing dmem.RAM write port 0.
  Analyzing regfile.rf write port 0.

16.19.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

16.19.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).
Checking read port `\RAM'[0] in module `\dmem': no output FF found.
Checking read port address `\RAM'[0] in module `\dmem': no address FF found.
Checking read port `\RAM'[0] in module `\imem': no output FF found.
Checking read port address `\RAM'[0] in module `\imem': no address FF found.
Checking read port `\rf'[0] in module `\regfile': no output FF found.
Checking read port `\rf'[1] in module `\regfile': no output FF found.
Checking read port address `\rf'[0] in module `\regfile': no address FF found.
Checking read port address `\rf'[1] in module `\regfile': no address FF found.

16.19.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.19.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).
Consolidating read ports of memory regfile.rf by address:

16.19.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

16.19.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.19.10. Executing MEMORY_COLLECT pass (generating $mem cells).

16.20. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.21. Executing MEMORY_LIBMAP pass (mapping memories to cells).
using FF mapping for memory dmem.RAM
using FF mapping for memory imem.RAM
using FF mapping for memory regfile.rf
<suppressed ~18 debug messages>

16.22. Executing TECHMAP pass (map to technology primitives).

16.22.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K_'.
Successfully finished Verilog frontend.

16.22.2. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/spram_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/spram_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_SPRAM_'.
Successfully finished Verilog frontend.

16.22.3. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~4 debug messages>

16.23. Executing ICE40_BRAMINIT pass.

16.24. Executing OPT pass (performing simple optimizations).

16.24.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~2 debug messages>
Optimizing module arm.
Optimizing module condcheck.
<suppressed ~1 debug messages>
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~3 debug messages>
Optimizing module dmem.
<suppressed ~3 debug messages>
Optimizing module extend.
<suppressed ~1 debug messages>
Optimizing module imem.
Optimizing module regfile.
<suppressed ~3 debug messages>

16.24.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.24.3. Executing OPT_DFF pass (perform DFF optimizations).

16.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 5 unused cells and 13 unused wires.
<suppressed ~11 debug messages>

16.24.5. Finished fast OPT passes.

16.25. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).
Mapping memory \RAM in module \dmem:
  created 2 $dff cells and 0 static cells of width 32.
  read interface: 0 $dff and 1 $mux cells.
  write interface: 2 write mux blocks.
Mapping memory \RAM in module \imem:
  created 64 $dff cells and 0 static cells of width 32.
  read interface: 0 $dff and 63 $mux cells.
  write interface: 0 write mux blocks.
Mapping memory \rf in module \regfile:
  created 15 $dff cells and 0 static cells of width 32.
  read interface: 0 $dff and 30 $mux cells.
  write interface: 15 write mux blocks.

16.26. Executing OPT pass (performing simple optimizations).

16.26.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
<suppressed ~2 debug messages>
Optimizing module extend.
Optimizing module imem.
<suppressed ~46 debug messages>
Optimizing module regfile.
<suppressed ~13 debug messages>

16.26.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~32 debug messages>

16.26.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
    Consolidated identical input bits for $mux cell $procmux$596:
      Old ports: A=10'1001110100, B=10'0001111000, Y=$3\controls[9:0]
      New ports: A=2'01, B=2'10, Y=$3\controls[9:0] [3:2]
      New connections: { $3\controls[9:0] [9:4] $3\controls[9:0] [1:0] } = { $3\controls[9:0] [2] 7'0011100 }
    Consolidated identical input bits for $mux cell $procmux$604:
      Old ports: A=6'001001, B=6'101001, Y=$2\controls[9:0]
      New ports: A=1'0, B=1'1, Y=$2\controls[9:0] [5]
      New connections: $2\controls[9:0] [4:0] = 5'01001
  Optimizing cells in module \decoder.
    Consolidated identical input bits for $pmux cell $procmux$609:
      Old ports: A={ 4'0000 $2\controls[9:0] }, B={ $3\controls[9:0] 10'0110100010 }, Y=\controls
      New ports: A={ $2\controls[9:0] [5] 5'01001 }, B={ 2'11 $3\controls[9:0] [3:2] 8'00100010 }, Y=\controls [5:0]
      New connections: \controls [9:6] = { \controls [2:1] \controls [1] \controls [4] }
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
    Consolidated identical input bits for $pmux cell $procmux$562:
      Old ports: A={ 24'000000000000000000000000 \Instr [7:0] }, B={ 20'00000000000000000000 \Instr [11:0] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr [23] \Instr 2'00 }, Y=\ExtImm
      New ports: A={ 18'000000000000000000 \Instr [7:0] }, B={ 14'00000000000000 \Instr [11:0] \Instr 2'00 }, Y=\ExtImm [25:0]
      New connections: \ExtImm [31:26] = { \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] \ExtImm [25] }
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][4]$826:
      Old ports: A=167772163, B=32'11100010100000110011000000000001, Y=$memory\RAM$rdmux[0][4][2]$a$773
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [1] }
      New connections: { $memory\RAM$rdmux[0][4][2]$a$773 [31:13] $memory\RAM$rdmux[0][4][2]$a$773 [11:2] $memory\RAM$rdmux[0][4][2]$a$773 [0] } = { $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [12] 1'0 $memory\RAM$rdmux[0][4][2]$a$773 [1] 3'010 $memory\RAM$rdmux[0][4][2]$a$773 [12] 5'00000 $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [12] 2'00 $memory\RAM$rdmux[0][4][2]$a$773 [12] 11'00000000001 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][6]$832:
      Old ports: A=452984825, B=32'11100101100000000011000000000000, Y=$memory\RAM$rdmux[0][4][3]$a$776
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [0] }
      New connections: { $memory\RAM$rdmux[0][4][3]$a$776 [31:25] $memory\RAM$rdmux[0][4][3]$a$776 [23:1] } = { $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [0] 1'1 $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] 2'11 $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] $memory\RAM$rdmux[0][4][3]$a$776 [0] 2'00 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][7]$835:
      Old ports: A=32'11101010111111111111111111110111, B=32'x, Y=$memory\RAM$rdmux[0][4][3]$b$777
      New ports: A=2'01, B=2'x, Y={ $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] }
      New connections: { $memory\RAM$rdmux[0][4][3]$b$777 [31:4] $memory\RAM$rdmux[0][4][3]$b$777 [2:1] } = { $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][3]$823:
      Old ports: A=32'11100101100001000011000000000000, B=32'11100000010100110011000000000010, Y=$memory\RAM$rdmux[0][4][1]$b$771
      New ports: A=2'10, B=2'01, Y={ $memory\RAM$rdmux[0][4][1]$b$771 [18] $memory\RAM$rdmux[0][4][1]$b$771 [1] }
      New connections: { $memory\RAM$rdmux[0][4][1]$b$771 [31:19] $memory\RAM$rdmux[0][4][1]$b$771 [17:2] $memory\RAM$rdmux[0][4][1]$b$771 [0] } = { 5'11100 $memory\RAM$rdmux[0][4][1]$b$771 [18] 1'0 $memory\RAM$rdmux[0][4][1]$b$771 [18] $memory\RAM$rdmux[0][4][1]$b$771 [18] $memory\RAM$rdmux[0][4][1]$b$771 [1] 1'0 $memory\RAM$rdmux[0][4][1]$b$771 [1] 1'0 $memory\RAM$rdmux[0][4][1]$b$771 [1] $memory\RAM$rdmux[0][4][1]$b$771 [1] 15'001100000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][5]$829:
      Old ports: A=32'11100101100001000011000000000000, B=32'11100000010100110011000000000010, Y=$memory\RAM$rdmux[0][4][2]$b$774
      New ports: A=2'10, B=2'01, Y={ $memory\RAM$rdmux[0][4][2]$b$774 [18] $memory\RAM$rdmux[0][4][2]$b$774 [1] }
      New connections: { $memory\RAM$rdmux[0][4][2]$b$774 [31:19] $memory\RAM$rdmux[0][4][2]$b$774 [17:2] $memory\RAM$rdmux[0][4][2]$b$774 [0] } = { 5'11100 $memory\RAM$rdmux[0][4][2]$b$774 [18] 1'0 $memory\RAM$rdmux[0][4][2]$b$774 [18] $memory\RAM$rdmux[0][4][2]$b$774 [18] $memory\RAM$rdmux[0][4][2]$b$774 [1] 1'0 $memory\RAM$rdmux[0][4][2]$b$774 [1] 1'0 $memory\RAM$rdmux[0][4][2]$b$774 [1] $memory\RAM$rdmux[0][4][2]$b$774 [1] 15'001100000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][2]$820:
      Old ports: A=32'11100010100000110011000000000100, B=32'11100101100111110100000000100000, Y=$memory\RAM$rdmux[0][4][1]$a$770
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [2] }
      New connections: { $memory\RAM$rdmux[0][4][1]$a$770 [31:6] $memory\RAM$rdmux[0][4][1]$a$770 [4:3] $memory\RAM$rdmux[0][4][1]$a$770 [1:0] } = { 5'11100 $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [2] $memory\RAM$rdmux[0][4][1]$a$770 [5] 3'100 $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [5] 3'110 $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [2] $memory\RAM$rdmux[0][4][1]$a$770 [2] 10'0000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][0]$814:
      Old ports: A=32'11100000010011110000000000001111, B=32'11100011101000000001000000000001, Y=$memory\RAM$rdmux[0][4][0]$a$767
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [1] }
      New connections: { $memory\RAM$rdmux[0][4][0]$a$767 [31:13] $memory\RAM$rdmux[0][4][0]$a$767 [11:2] $memory\RAM$rdmux[0][4][0]$a$767 [0] } = { 6'111000 $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [12] 1'0 $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [1] 11'00000000000 $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][5][1]$817:
      Old ports: A=32'11100011101000000010000011111111, B=32'11100010100000000011000011101010, Y=$memory\RAM$rdmux[0][4][0]$b$768
      New ports: A=2'01, B=2'10, Y={ $memory\RAM$rdmux[0][4][0]$b$768 [12] $memory\RAM$rdmux[0][4][0]$b$768 [0] }
      New connections: { $memory\RAM$rdmux[0][4][0]$b$768 [31:13] $memory\RAM$rdmux[0][4][0]$b$768 [11:1] } = { 7'1110001 $memory\RAM$rdmux[0][4][0]$b$768 [0] 2'10 $memory\RAM$rdmux[0][4][0]$b$768 [0] 15'000000010000111 $memory\RAM$rdmux[0][4][0]$b$768 [0] 1'1 $memory\RAM$rdmux[0][4][0]$b$768 [0] 1'1 }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][0]$766:
      Old ports: A=$memory\RAM$rdmux[0][4][0]$a$767, B=$memory\RAM$rdmux[0][4][0]$b$768, Y=$memory\RAM$rdmux[0][3][0]$a$743
      New ports: A={ $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [12] $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [12] 2'00 $memory\RAM$rdmux[0][4][0]$a$767 [1] $memory\RAM$rdmux[0][4][0]$a$767 [1] 1'1 }, B={ 1'1 $memory\RAM$rdmux[0][4][0]$b$768 [0] 1'0 $memory\RAM$rdmux[0][4][0]$b$768 [12] 1'1 $memory\RAM$rdmux[0][4][0]$b$768 [0] $memory\RAM$rdmux[0][4][0]$b$768 [0] 1'1 $memory\RAM$rdmux[0][4][0]$b$768 [0] }, Y={ $memory\RAM$rdmux[0][3][0]$a$743 [23] $memory\RAM$rdmux[0][3][0]$a$743 [21] $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [12] $memory\RAM$rdmux[0][3][0]$a$743 [5:4] $memory\RAM$rdmux[0][3][0]$a$743 [2:0] }
      New connections: { $memory\RAM$rdmux[0][3][0]$a$743 [31:24] $memory\RAM$rdmux[0][3][0]$a$743 [22] $memory\RAM$rdmux[0][3][0]$a$743 [20:17] $memory\RAM$rdmux[0][3][0]$a$743 [15:13] $memory\RAM$rdmux[0][3][0]$a$743 [11:6] $memory\RAM$rdmux[0][3][0]$a$743 [3] } = { 6'111000 $memory\RAM$rdmux[0][3][0]$a$743 [23] $memory\RAM$rdmux[0][3][0]$a$743 [21] $memory\RAM$rdmux[0][3][0]$a$743 [16] 1'0 $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [16] 2'00 $memory\RAM$rdmux[0][3][0]$a$743 [5] 4'0000 $memory\RAM$rdmux[0][3][0]$a$743 [5] $memory\RAM$rdmux[0][3][0]$a$743 [5] $memory\RAM$rdmux[0][3][0]$a$743 [1] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][3]$775:
      Old ports: A=$memory\RAM$rdmux[0][4][3]$a$776, B=$memory\RAM$rdmux[0][4][3]$b$777, Y=$memory\RAM$rdmux[0][3][1]$b$747
      New ports: A={ $memory\RAM$rdmux[0][4][3]$a$776 [24] $memory\RAM$rdmux[0][4][3]$a$776 [24] 1'1 $memory\RAM$rdmux[0][4][3]$a$776 [0] 1'0 $memory\RAM$rdmux[0][4][3]$a$776 [0] }, B={ $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [3] $memory\RAM$rdmux[0][4][3]$b$777 [0] $memory\RAM$rdmux[0][4][3]$b$777 [0] }, Y={ $memory\RAM$rdmux[0][3][1]$b$747 [29] $memory\RAM$rdmux[0][3][1]$b$747 [24] $memory\RAM$rdmux[0][3][1]$b$747 [12] $memory\RAM$rdmux[0][3][1]$b$747 [3] $memory\RAM$rdmux[0][3][1]$b$747 [1:0] }
      New connections: { $memory\RAM$rdmux[0][3][1]$b$747 [31:30] $memory\RAM$rdmux[0][3][1]$b$747 [28:25] $memory\RAM$rdmux[0][3][1]$b$747 [23:13] $memory\RAM$rdmux[0][3][1]$b$747 [11:4] $memory\RAM$rdmux[0][3][1]$b$747 [2] } = { $memory\RAM$rdmux[0][3][1]$b$747 [29] $memory\RAM$rdmux[0][3][1]$b$747 [29] $memory\RAM$rdmux[0][3][1]$b$747 [3] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [24] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [12] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [12] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [1] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][2]$772:
      Old ports: A=$memory\RAM$rdmux[0][4][2]$a$773, B=$memory\RAM$rdmux[0][4][2]$b$774, Y=$memory\RAM$rdmux[0][3][1]$a$746
      New ports: A={ $memory\RAM$rdmux[0][4][2]$a$773 [1] $memory\RAM$rdmux[0][4][2]$a$773 [12] 2'00 $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [12] $memory\RAM$rdmux[0][4][2]$a$773 [1] 1'1 }, B={ 1'0 $memory\RAM$rdmux[0][4][2]$b$774 [18] $memory\RAM$rdmux[0][4][2]$b$774 [1] $memory\RAM$rdmux[0][4][2]$b$774 [18] $memory\RAM$rdmux[0][4][2]$b$774 [1] 1'1 $memory\RAM$rdmux[0][4][2]$b$774 [1] 1'0 }, Y={ $memory\RAM$rdmux[0][3][1]$a$746 [27] $memory\RAM$rdmux[0][3][1]$a$746 [23] $memory\RAM$rdmux[0][3][1]$a$746 [20] $memory\RAM$rdmux[0][3][1]$a$746 [18] $memory\RAM$rdmux[0][3][1]$a$746 [16] $memory\RAM$rdmux[0][3][1]$a$746 [12] $memory\RAM$rdmux[0][3][1]$a$746 [1:0] }
      New connections: { $memory\RAM$rdmux[0][3][1]$a$746 [31:28] $memory\RAM$rdmux[0][3][1]$a$746 [26:24] $memory\RAM$rdmux[0][3][1]$a$746 [22:21] $memory\RAM$rdmux[0][3][1]$a$746 [19] $memory\RAM$rdmux[0][3][1]$a$746 [17] $memory\RAM$rdmux[0][3][1]$a$746 [15:13] $memory\RAM$rdmux[0][3][1]$a$746 [11:2] } = { $memory\RAM$rdmux[0][3][1]$a$746 [12] $memory\RAM$rdmux[0][3][1]$a$746 [12] $memory\RAM$rdmux[0][3][1]$a$746 [12] 1'0 $memory\RAM$rdmux[0][3][1]$a$746 [18] $memory\RAM$rdmux[0][3][1]$a$746 [0] $memory\RAM$rdmux[0][3][1]$a$746 [18] $memory\RAM$rdmux[0][3][1]$a$746 [20] 2'00 $memory\RAM$rdmux[0][3][1]$a$746 [16] 2'00 $memory\RAM$rdmux[0][3][1]$a$746 [12] 10'0000000000 }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][1]$769:
      Old ports: A=$memory\RAM$rdmux[0][4][1]$a$770, B=$memory\RAM$rdmux[0][4][1]$b$771, Y=$memory\RAM$rdmux[0][3][0]$b$744
      New ports: A={ 1'1 $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [5] 1'1 $memory\RAM$rdmux[0][4][1]$a$770 [2] $memory\RAM$rdmux[0][4][1]$a$770 [5] $memory\RAM$rdmux[0][4][1]$a$770 [2] 1'0 }, B={ $memory\RAM$rdmux[0][4][1]$b$771 [18] $memory\RAM$rdmux[0][4][1]$b$771 [1] $memory\RAM$rdmux[0][4][1]$b$771 [18] $memory\RAM$rdmux[0][4][1]$b$771 [1] 3'100 $memory\RAM$rdmux[0][4][1]$b$771 [1] }, Y={ $memory\RAM$rdmux[0][3][0]$b$744 [23] $memory\RAM$rdmux[0][3][0]$b$744 [20] $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [16] $memory\RAM$rdmux[0][3][0]$b$744 [12] $memory\RAM$rdmux[0][3][0]$b$744 [5] $memory\RAM$rdmux[0][3][0]$b$744 [2:1] }
      New connections: { $memory\RAM$rdmux[0][3][0]$b$744 [31:24] $memory\RAM$rdmux[0][3][0]$b$744 [22:21] $memory\RAM$rdmux[0][3][0]$b$744 [19] $memory\RAM$rdmux[0][3][0]$b$744 [17] $memory\RAM$rdmux[0][3][0]$b$744 [15:13] $memory\RAM$rdmux[0][3][0]$b$744 [11:6] $memory\RAM$rdmux[0][3][0]$b$744 [4:3] $memory\RAM$rdmux[0][3][0]$b$744 [0] } = { 5'11100 $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [2] $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [1] 1'0 $memory\RAM$rdmux[0][3][0]$b$744 [5] $memory\RAM$rdmux[0][3][0]$b$744 [16] 1'0 $memory\RAM$rdmux[0][3][0]$b$744 [5] $memory\RAM$rdmux[0][3][0]$b$744 [12] 9'000000000 }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][3][1]$745:
      Old ports: A=$memory\RAM$rdmux[0][3][1]$a$746, B=$memory\RAM$rdmux[0][3][1]$b$747, Y=$memory\RAM$rdmux[0][2][0]$b$732
      New ports: A={ $memory\RAM$rdmux[0][3][1]$a$746 [12] $memory\RAM$rdmux[0][3][1]$a$746 [27] $memory\RAM$rdmux[0][3][1]$a$746 [18] $memory\RAM$rdmux[0][3][1]$a$746 [23] $memory\RAM$rdmux[0][3][1]$a$746 [20] $memory\RAM$rdmux[0][3][1]$a$746 [18] $memory\RAM$rdmux[0][3][1]$a$746 [16] $memory\RAM$rdmux[0][3][1]$a$746 [12] 3'000 $memory\RAM$rdmux[0][3][1]$a$746 [1:0] }, B={ $memory\RAM$rdmux[0][3][1]$b$747 [29] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [24] $memory\RAM$rdmux[0][3][1]$b$747 [12] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [12] $memory\RAM$rdmux[0][3][1]$b$747 [0] $memory\RAM$rdmux[0][3][1]$b$747 [3] $memory\RAM$rdmux[0][3][1]$b$747 [1] $memory\RAM$rdmux[0][3][1]$b$747 [1:0] }, Y={ $memory\RAM$rdmux[0][2][0]$b$732 [29] $memory\RAM$rdmux[0][2][0]$b$732 [27] $memory\RAM$rdmux[0][2][0]$b$732 [24:23] $memory\RAM$rdmux[0][2][0]$b$732 [20] $memory\RAM$rdmux[0][2][0]$b$732 [18] $memory\RAM$rdmux[0][2][0]$b$732 [16] $memory\RAM$rdmux[0][2][0]$b$732 [12] $memory\RAM$rdmux[0][2][0]$b$732 [4:0] }
      New connections: { $memory\RAM$rdmux[0][2][0]$b$732 [31:30] $memory\RAM$rdmux[0][2][0]$b$732 [28] $memory\RAM$rdmux[0][2][0]$b$732 [26:25] $memory\RAM$rdmux[0][2][0]$b$732 [22:21] $memory\RAM$rdmux[0][2][0]$b$732 [19] $memory\RAM$rdmux[0][2][0]$b$732 [17] $memory\RAM$rdmux[0][2][0]$b$732 [15:13] $memory\RAM$rdmux[0][2][0]$b$732 [11:5] } = { $memory\RAM$rdmux[0][2][0]$b$732 [29] $memory\RAM$rdmux[0][2][0]$b$732 [29] $memory\RAM$rdmux[0][2][0]$b$732 [3] $memory\RAM$rdmux[0][2][0]$b$732 [24] $memory\RAM$rdmux[0][2][0]$b$732 [0] $memory\RAM$rdmux[0][2][0]$b$732 [20] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [16] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [12] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] }
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][3][0]$742:
      Old ports: A=$memory\RAM$rdmux[0][3][0]$a$743, B=$memory\RAM$rdmux[0][3][0]$b$744, Y=$memory\RAM$rdmux[0][2][0]$a$731
      New ports: A={ 1'0 $memory\RAM$rdmux[0][3][0]$a$743 [23] $memory\RAM$rdmux[0][3][0]$a$743 [21] $memory\RAM$rdmux[0][3][0]$a$743 [23] $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [21] 1'0 $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [16] $memory\RAM$rdmux[0][3][0]$a$743 [16] 1'0 $memory\RAM$rdmux[0][3][0]$a$743 [5] $memory\RAM$rdmux[0][3][0]$a$743 [12] $memory\RAM$rdmux[0][3][0]$a$743 [5] $memory\RAM$rdmux[0][3][0]$a$743 [5:4] $memory\RAM$rdmux[0][3][0]$a$743 [1] $memory\RAM$rdmux[0][3][0]$a$743 [2:0] }, B={ $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [2] $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [23] $memory\RAM$rdmux[0][3][0]$b$744 [1] 1'0 $memory\RAM$rdmux[0][3][0]$b$744 [20] $memory\RAM$rdmux[0][3][0]$b$744 [5] $memory\RAM$rdmux[0][3][0]$b$744 [18] $memory\RAM$rdmux[0][3][0]$b$744 [16] $memory\RAM$rdmux[0][3][0]$b$744 [5] $memory\RAM$rdmux[0][3][0]$b$744 [12] $memory\RAM$rdmux[0][3][0]$b$744 [12] 1'0 $memory\RAM$rdmux[0][3][0]$b$744 [5] 2'00 $memory\RAM$rdmux[0][3][0]$b$744 [2:1] 1'0 }, Y={ $memory\RAM$rdmux[0][2][0]$a$731 [26:18] $memory\RAM$rdmux[0][2][0]$a$731 [16] $memory\RAM$rdmux[0][2][0]$a$731 [14:12] $memory\RAM$rdmux[0][2][0]$a$731 [6:0] }
      New connections: { $memory\RAM$rdmux[0][2][0]$a$731 [31:27] $memory\RAM$rdmux[0][2][0]$a$731 [17] $memory\RAM$rdmux[0][2][0]$a$731 [15] $memory\RAM$rdmux[0][2][0]$a$731 [11:7] } = { 5'11100 $memory\RAM$rdmux[0][2][0]$a$731 [16] 5'00000 $memory\RAM$rdmux[0][2][0]$a$731 [6] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][2][0]$730:
      Old ports: A=$memory\RAM$rdmux[0][2][0]$a$731, B=$memory\RAM$rdmux[0][2][0]$b$732, Y=$memory\RAM$rdmux[0][1][0]$a$725
      New ports: A={ 3'100 $memory\RAM$rdmux[0][2][0]$a$731 [26:18] $memory\RAM$rdmux[0][2][0]$a$731 [16] $memory\RAM$rdmux[0][2][0]$a$731 [14:12] 1'0 $memory\RAM$rdmux[0][2][0]$a$731 [6:0] }, B={ $memory\RAM$rdmux[0][2][0]$b$732 [29] $memory\RAM$rdmux[0][2][0]$b$732 [3] $memory\RAM$rdmux[0][2][0]$b$732 [27] $memory\RAM$rdmux[0][2][0]$b$732 [24] $memory\RAM$rdmux[0][2][0]$b$732 [0] $memory\RAM$rdmux[0][2][0]$b$732 [24:23] $memory\RAM$rdmux[0][2][0]$b$732 [20] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [20] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [18] $memory\RAM$rdmux[0][2][0]$b$732 [16] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [12] $memory\RAM$rdmux[0][2][0]$b$732 [12] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4] $memory\RAM$rdmux[0][2][0]$b$732 [4:0] }, Y={ $memory\RAM$rdmux[0][1][0]$a$725 [29:18] $memory\RAM$rdmux[0][1][0]$a$725 [16] $memory\RAM$rdmux[0][1][0]$a$725 [14:12] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [6:0] }
      New connections: { $memory\RAM$rdmux[0][1][0]$a$725 [31:30] $memory\RAM$rdmux[0][1][0]$a$725 [17] $memory\RAM$rdmux[0][1][0]$a$725 [15] $memory\RAM$rdmux[0][1][0]$a$725 [11:9] $memory\RAM$rdmux[0][1][0]$a$725 [7] } = { $memory\RAM$rdmux[0][1][0]$a$725 [29] $memory\RAM$rdmux[0][1][0]$a$725 [29] $memory\RAM$rdmux[0][1][0]$a$725 [16] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [6] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][1][0]$724:
      Old ports: A=$memory\RAM$rdmux[0][1][0]$a$725, B=32'x, Y=$memory\RAM$rdmux[0][0][0]$a$722
      New ports: A={ $memory\RAM$rdmux[0][1][0]$a$725 [29:18] $memory\RAM$rdmux[0][1][0]$a$725 [16] $memory\RAM$rdmux[0][1][0]$a$725 [14:12] $memory\RAM$rdmux[0][1][0]$a$725 [8] $memory\RAM$rdmux[0][1][0]$a$725 [6:0] }, B=24'x, Y={ $memory\RAM$rdmux[0][0][0]$a$722 [29:18] $memory\RAM$rdmux[0][0][0]$a$722 [16] $memory\RAM$rdmux[0][0][0]$a$722 [14:12] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [6:0] }
      New connections: { $memory\RAM$rdmux[0][0][0]$a$722 [31:30] $memory\RAM$rdmux[0][0][0]$a$722 [17] $memory\RAM$rdmux[0][0][0]$a$722 [15] $memory\RAM$rdmux[0][0][0]$a$722 [11:9] $memory\RAM$rdmux[0][0][0]$a$722 [7] } = { $memory\RAM$rdmux[0][0][0]$a$722 [29] $memory\RAM$rdmux[0][0][0]$a$722 [29] $memory\RAM$rdmux[0][0][0]$a$722 [16] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [6] }
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][0][0]$721:
      Old ports: A=$memory\RAM$rdmux[0][0][0]$a$722, B=32'x, Y=\rd
      New ports: A={ $memory\RAM$rdmux[0][0][0]$a$722 [29:18] $memory\RAM$rdmux[0][0][0]$a$722 [16] $memory\RAM$rdmux[0][0][0]$a$722 [14:12] $memory\RAM$rdmux[0][0][0]$a$722 [8] $memory\RAM$rdmux[0][0][0]$a$722 [6:0] }, B=24'x, Y={ \rd [29:18] \rd [16] \rd [14:12] \rd [8] \rd [6:0] }
      New connections: { \rd [31:30] \rd [17] \rd [15] \rd [11:9] \rd [7] } = { \rd [29] \rd [29] \rd [16] \rd [8] \rd [8] \rd [8] \rd [8] \rd [6] }
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 21 changes.

16.26.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
<suppressed ~15 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 5 cells.

16.26.6. Executing OPT_DFF pass (perform DFF optimizations).

16.26.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 171 unused wires.
<suppressed ~3 debug messages>

16.26.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.9. Rerunning OPT passes. (Maybe there is more to do..)

16.26.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~34 debug messages>

16.26.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
    Consolidated identical input bits for $mux cell $memory\RAM$rdmux[0][4][0]$766:
      Old ports: A={ $memory\RAM$rdmux[0][4][0]$a$767 [25] $memory\RAM$rdmux[0][4][0]$a$767 [25] $memory\RAM$rdmux[0][4][0]$a$767 [22] $memory\RAM$rdmux[0][4][0]$a$767 [25] 2'00 $memory\RAM$rdmux[0][4][0]$a$767 [22] $memory\RAM$rdmux[0][4][0]$a$767 [22] 1'1 }, B={ 1'1 $memory\RAM$rdmux[0][4][0]$a$767 [22] 1'0 $memory\RAM$rdmux[0][4][0]$a$767 [25] 1'1 $memory\RAM$rdmux[0][4][0]$a$767 [22] $memory\RAM$rdmux[0][4][0]$a$767 [22] 1'1 $memory\RAM$rdmux[0][4][0]$a$767 [22] }, Y={ $memory\RAM$rdmux[0][3][0]$a$743 [25:24] $memory\RAM$rdmux[0][3][0]$a$743 [22] $memory\RAM$rdmux[0][3][0]$a$743 [12] $memory\RAM$rdmux[0][3][0]$a$743 [13] $memory\RAM$rdmux[0][3][0]$a$743 [4] $memory\RAM$rdmux[0][3][0]$a$743 [2] $memory\RAM$rdmux[0][3][0]$a$743 [3] $memory\RAM$rdmux[0][3][0]$a$743 [0] }
      New ports: A={ $memory\RAM$rdmux[0][4][0]$a$767 [25] $memory\RAM$rdmux[0][4][0]$a$767 [25] $memory\RAM$rdmux[0][4][0]$a$767 [22] 2'00 $memory\RAM$rdmux[0][4][0]$a$767 [22] 1'1 }, B={ 1'1 $memory\RAM$rdmux[0][4][0]$a$767 [22] 2'01 $memory\RAM$rdmux[0][4][0]$a$767 [22] 1'1 $memory\RAM$rdmux[0][4][0]$a$767 [22] }, Y={ $memory\RAM$rdmux[0][3][0]$a$743 [25:24] $memory\RAM$rdmux[0][3][0]$a$743 [22] $memory\RAM$rdmux[0][3][0]$a$743 [13] $memory\RAM$rdmux[0][3][0]$a$743 [4:3] $memory\RAM$rdmux[0][3][0]$a$743 [0] }
      New connections: { $memory\RAM$rdmux[0][3][0]$a$743 [12] $memory\RAM$rdmux[0][3][0]$a$743 [2] } = { $memory\RAM$rdmux[0][4][0]$a$767 [25] $memory\RAM$rdmux[0][4][0]$a$767 [22] }
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 1 changes.

16.26.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.13. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $memory\RAM[1]$704 ($dff) from module dmem (D = \wd, Q = \RAM[1]).
Adding EN signal on $memory\RAM[0]$702 ($dff) from module dmem (D = \wd, Q = \RAM[0]).
Adding EN signal on $memory\rf[9]$928 ($dff) from module regfile (D = \wd3, Q = \rf[9]).
Adding EN signal on $memory\rf[8]$926 ($dff) from module regfile (D = \wd3, Q = \rf[8]).
Adding EN signal on $memory\rf[7]$924 ($dff) from module regfile (D = \wd3, Q = \rf[7]).
Adding EN signal on $memory\rf[6]$922 ($dff) from module regfile (D = \wd3, Q = \rf[6]).
Adding EN signal on $memory\rf[5]$920 ($dff) from module regfile (D = \wd3, Q = \rf[5]).
Adding EN signal on $memory\rf[4]$918 ($dff) from module regfile (D = \wd3, Q = \rf[4]).
Adding EN signal on $memory\rf[3]$916 ($dff) from module regfile (D = \wd3, Q = \rf[3]).
Adding EN signal on $memory\rf[2]$914 ($dff) from module regfile (D = \wd3, Q = \rf[2]).
Adding EN signal on $memory\rf[1]$912 ($dff) from module regfile (D = \wd3, Q = \rf[1]).
Adding EN signal on $memory\rf[14]$938 ($dff) from module regfile (D = \wd3, Q = \rf[14]).
Adding EN signal on $memory\rf[13]$936 ($dff) from module regfile (D = \wd3, Q = \rf[13]).
Adding EN signal on $memory\rf[12]$934 ($dff) from module regfile (D = \wd3, Q = \rf[12]).
Adding EN signal on $memory\rf[11]$932 ($dff) from module regfile (D = \wd3, Q = \rf[11]).
Adding EN signal on $memory\rf[10]$930 ($dff) from module regfile (D = \wd3, Q = \rf[10]).
Adding EN signal on $memory\rf[0]$910 ($dff) from module regfile (D = \wd3, Q = \rf[0]).

16.26.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 17 unused cells and 18 unused wires.
<suppressed ~20 debug messages>

16.26.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.16. Rerunning OPT passes. (Maybe there is more to do..)

16.26.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \arm..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \condcheck..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \condlogic..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \controller..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cpu_main..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \datapath..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \decoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dmem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \extend..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \imem..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

16.26.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
  Optimizing cells in module \arm.
  Optimizing cells in module \condcheck.
  Optimizing cells in module \condlogic.
  Optimizing cells in module \controller.
  Optimizing cells in module \cpu_main.
  Optimizing cells in module \datapath.
  Optimizing cells in module \decoder.
  Optimizing cells in module \dmem.
  Optimizing cells in module \extend.
  Optimizing cells in module \imem.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

16.26.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.26.20. Executing OPT_DFF pass (perform DFF optimizations).

16.26.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.26.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.26.23. Finished OPT passes. (There is nothing left to do.)

16.27. Executing ICE40_WRAPCARRY pass (wrap carries).

16.28. Executing TECHMAP pass (map to technology primitives).

16.28.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.28.2. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

16.28.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $dffe.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $and.
Using template $paramod$55fabc38af77a7e92aab69f00033bfed03b847e2\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $or.
Using template $paramod$97565c3687be688407d1272a293bd9d0ae6852dc\_90_pmux for cells of type $pmux.
Using template $paramod$ed0bb9616228df1e6c226f91f8133e751815f1b1\_90_pmux for cells of type $pmux.
Using template $paramod$3ab9a015ab781a81f86ab59e92093de7732cf40e\_90_pmux for cells of type $pmux.
Using template $paramod$857150d3a9b7fb38b73bbaa31ff652415e553f98\_80_ice40_alu for cells of type $alu.
Using template $paramod$8fabc56b80a569262acfc42757a02ca0b8e91278\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $adff.
Using extmapper simplemap for cells of type $adffe.
Using template $paramod$fbc7873bff55778c0b3173955b7e4bce1d9d6834\_80_ice40_alu for cells of type $alu.
No more expansions possible.
<suppressed ~458 debug messages>

16.29. Executing OPT pass (performing simple optimizations).

16.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
<suppressed ~32 debug messages>
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~39 debug messages>
Optimizing module arm.
Optimizing module condcheck.
<suppressed ~58 debug messages>
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~47 debug messages>
Optimizing module dmem.
Optimizing module extend.
<suppressed ~36 debug messages>
Optimizing module imem.
<suppressed ~5 debug messages>
Optimizing module regfile.
<suppressed ~72 debug messages>

16.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
<suppressed ~3 debug messages>
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
<suppressed ~132 debug messages>
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
<suppressed ~12 debug messages>
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
<suppressed ~30 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 59 cells.

16.29.3. Executing OPT_DFF pass (perform DFF optimizations).

16.29.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 131 unused cells and 412 unused wires.
<suppressed ~139 debug messages>

16.29.5. Finished fast OPT passes.

16.30. Executing ICE40_OPT pass (performing simple optimizations).

16.30.1. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) alu.$auto$alumacc.cc:485:replace_alu$671.slice[32].carry: CO=1'0

16.30.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~1 debug messages>
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
<suppressed ~53 debug messages>
Optimizing module regfile.
<suppressed ~64 debug messages>

16.30.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
<suppressed ~15 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 5 cells.

16.30.4. Executing OPT_DFF pass (perform DFF optimizations).

16.30.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 7 unused wires.
<suppressed ~3 debug messages>

16.30.6. Rerunning OPT passes. (Removed registers in this run.)

16.30.7. Running ICE40 specific optimizations.

16.30.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
<suppressed ~1 debug messages>
Optimizing module regfile.

16.30.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.30.10. Executing OPT_DFF pass (perform DFF optimizations).

16.30.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.30.12. Rerunning OPT passes. (Removed registers in this run.)

16.30.13. Running ICE40 specific optimizations.

16.30.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.30.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.30.16. Executing OPT_DFF pass (perform DFF optimizations).

16.30.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.30.18. Finished OPT passes. (There is nothing left to do.)

16.31. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).

16.32. Executing TECHMAP pass (map to technology primitives).

16.32.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

16.32.2. Continuing TECHMAP pass.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
Using template \$_DFF_PP0_ for cells of type $_DFF_PP0_.
Using template \$_DFFE_PP0P_ for cells of type $_DFFE_PP0P_.
No more expansions possible.
<suppressed ~600 debug messages>

16.33. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.34. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping alu.$auto$alumacc.cc:485:replace_alu$671.slice[32].carry ($lut).

16.35. Executing ICE40_OPT pass (performing simple optimizations).

16.35.1. Running ICE40 specific optimizations.

16.35.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~15 debug messages>
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
<suppressed ~5 debug messages>
Optimizing module dmem.
Optimizing module extend.
<suppressed ~18 debug messages>
Optimizing module imem.
<suppressed ~15 debug messages>
Optimizing module regfile.

16.35.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.35.4. Executing OPT_DFF pass (perform DFF optimizations).

16.35.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 2896 unused wires.
<suppressed ~5 debug messages>

16.35.6. Rerunning OPT passes. (Removed registers in this run.)

16.35.7. Running ICE40 specific optimizations.

16.35.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Optimizing module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
Optimizing module arm.
Optimizing module condcheck.
Optimizing module condlogic.
Optimizing module controller.
Optimizing module cpu_main.
Optimizing module datapath.
Optimizing module decoder.
Optimizing module dmem.
Optimizing module extend.
Optimizing module imem.
Optimizing module regfile.

16.35.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Finding identical cells in module `\arm'.
Finding identical cells in module `\condcheck'.
Finding identical cells in module `\condlogic'.
Finding identical cells in module `\controller'.
Finding identical cells in module `\cpu_main'.
Finding identical cells in module `\datapath'.
Finding identical cells in module `\decoder'.
Finding identical cells in module `\dmem'.
Finding identical cells in module `\extend'.
Finding identical cells in module `\imem'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

16.35.10. Executing OPT_DFF pass (perform DFF optimizations).

16.35.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \arm..
Finding unused cells or wires in module \condcheck..
Finding unused cells or wires in module \condlogic..
Finding unused cells or wires in module \controller..
Finding unused cells or wires in module \cpu_main..
Finding unused cells or wires in module \datapath..
Finding unused cells or wires in module \decoder..
Finding unused cells or wires in module \dmem..
Finding unused cells or wires in module \extend..
Finding unused cells or wires in module \imem..
Finding unused cells or wires in module \regfile..

16.35.12. Finished OPT passes. (There is nothing left to do.)

16.36. Executing TECHMAP pass (map to technology primitives).

16.36.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

16.36.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~4 debug messages>

16.37. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/abc9_model.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/abc9_model.v' to AST representation.
Generating RTLIL representation for module `$__ICE40_CARRY_WRAPPER'.
Successfully finished Verilog frontend.

16.38. Executing ABC9 pass.

16.38.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.3. Executing SCC pass (detecting logic loops).
Found 0 SCCs in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Found 0 SCCs in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100.
Found 0 SCCs in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000.
Found 0 SCCs in module alu.
Found 0 SCCs in module arm.
Found 0 SCCs in module condcheck.
Found 0 SCCs in module condlogic.
Found 0 SCCs in module controller.
Found 0 SCCs in module cpu_main.
Found 0 SCCs in module datapath.
Found 0 SCCs in module decoder.
Found 0 SCCs in module dmem.
Found 0 SCCs in module extend.
Found 0 SCCs in module imem.
Found 0 SCCs in module regfile.
Found 0 SCCs.

16.38.4. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.5. Executing PROC pass (convert processes to netlists).

16.38.5.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.38.5.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

16.38.5.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

16.38.5.4. Executing PROC_INIT pass (extract init attributes).

16.38.5.5. Executing PROC_ARST pass (detect async resets in processes).

16.38.5.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

16.38.5.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

16.38.5.8. Executing PROC_DLATCH pass (convert process syncs to latches).

16.38.5.9. Executing PROC_DFF pass (convert process syncs to FFs).

16.38.5.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

16.38.5.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

16.38.5.12. Executing OPT_EXPR pass (perform const folding).

16.38.6. Executing TECHMAP pass (map to technology primitives).

16.38.6.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.38.6.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~142 debug messages>

16.38.7. Executing OPT pass (performing simple optimizations).

16.38.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module SB_DFFER.
Optimizing module SB_DFFR.

16.38.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\SB_DFFER'.
Finding identical cells in module `\SB_DFFR'.
Removed a total of 0 cells.

16.38.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \SB_DFFER..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \SB_DFFR..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \SB_DFFER.
  Optimizing cells in module \SB_DFFR.
Performed a total of 0 changes.

16.38.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\SB_DFFER'.
Finding identical cells in module `\SB_DFFR'.
Removed a total of 0 cells.

16.38.7.6. Executing OPT_DFF pass (perform DFF optimizations).

16.38.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \SB_DFFER..
Finding unused cells or wires in module \SB_DFFR..

16.38.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module SB_DFFER.
Optimizing module SB_DFFR.

16.38.7.9. Finished OPT passes. (There is nothing left to do.)

16.38.8. Executing TECHMAP pass (map to technology primitives).

16.38.8.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_map.v' to AST representation.
Successfully finished Verilog frontend.

16.38.8.2. Continuing TECHMAP pass.
Using template SB_DFFR for cells of type SB_DFFR.
Using template SB_DFFER for cells of type SB_DFFER.
No more expansions possible.
<suppressed ~38 debug messages>

16.38.9. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_model.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_model.v' to AST representation.
Generating RTLIL representation for module `$__ABC9_DELAY'.
Generating RTLIL representation for module `$__ABC9_SCC_BREAKER'.
Generating RTLIL representation for module `$__DFF_N__$abc9_flop'.
Generating RTLIL representation for module `$__DFF_P__$abc9_flop'.
Successfully finished Verilog frontend.

16.38.10. Executing ABC9_OPS pass (helper functions for ABC9).
<suppressed ~8 debug messages>

16.38.11. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.12. Executing ABC9_OPS pass (helper functions for ABC9).
<suppressed ~2 debug messages>

16.38.13. Executing TECHMAP pass (map to technology primitives).

16.38.13.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

16.38.13.2. Continuing TECHMAP pass.
Using template $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 for cells of type $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1.
Using template $paramod\SB_LUT4\LUT_INIT=16'0110100110010110 for cells of type SB_LUT4.
Using template SB_CARRY for cells of type SB_CARRY.
Using extmapper simplemap for cells of type $logic_or.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $logic_and.
No more expansions possible.
<suppressed ~172 debug messages>

16.38.14. Executing OPT pass (performing simple optimizations).

16.38.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
<suppressed ~4 debug messages>
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.
<suppressed ~4 debug messages>

16.38.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
<suppressed ~29 debug messages>
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
<suppressed ~29 debug messages>
Removed a total of 24 cells.

16.38.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
Performed a total of 0 changes.

16.38.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Removed a total of 0 cells.

16.38.14.6. Executing OPT_DFF pass (perform DFF optimizations).

16.38.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..
Removed 0 unused cells and 48 unused wires.
<suppressed ~2 debug messages>

16.38.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.

16.38.14.9. Rerunning OPT passes. (Maybe there is more to do..)

16.38.14.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

16.38.14.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
  Optimizing cells in module \alu.
Performed a total of 0 changes.

16.38.14.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000'.
Finding identical cells in module `\alu'.
Removed a total of 0 cells.

16.38.14.13. Executing OPT_DFF pass (perform DFF optimizations).

16.38.14.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000..
Finding unused cells or wires in module \alu..

16.38.14.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\adder\WIDTH=s32'00000000000000000000000000100000.
Optimizing module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010.
Optimizing module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000.
Optimizing module alu.

16.38.14.16. Finished OPT passes. (There is nothing left to do.)

16.38.15. Executing AIGMAP pass (map logic to AIG).
Module $paramod\adder\WIDTH=s32'00000000000000000000000000100000: replaced 7 cells with 43 new cells, skipped 11 cells.
  replaced 2 cell types:
       2 $_OR_
       5 $_MUX_
  not replaced 3 cell types:
       8 $specify2
       1 $_NOT_
       2 $_AND_
Module alu: replaced 7 cells with 43 new cells, skipped 11 cells.
  replaced 2 cell types:
       2 $_OR_
       5 $_MUX_
  not replaced 3 cell types:
       8 $specify2
       1 $_NOT_
       2 $_AND_

16.38.16. Executing AIGMAP pass (map logic to AIG).
Module $paramod\adder\WIDTH=s32'00000000000000000000000000100000: replaced 0 cells with 0 new cells, skipped 32 cells.
  not replaced 1 cell types:
      32 $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1
Module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010: replaced 0 cells with 0 new cells, skipped 4 cells.
  not replaced 2 cell types:
       2 SB_DFFER
       2 SB_DFFER_$abc9_byp
Module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000: replaced 0 cells with 0 new cells, skipped 64 cells.
  not replaced 2 cell types:
      32 SB_DFFR
      32 SB_DFFR_$abc9_byp
Module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100: replaced 4 cells with 28 new cells, skipped 0 cells.
  replaced 1 cell types:
       4 $_MUX_
Module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000: replaced 32 cells with 224 new cells, skipped 0 cells.
  replaced 1 cell types:
      32 $_MUX_
Module alu: replaced 162 cells with 840 new cells, skipped 165 cells.
  replaced 2 cell types:
      98 $_OR_
      64 $_MUX_
  not replaced 3 cell types:
      37 $_NOT_
      96 $_AND_
      32 $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1
Module arm: replaced 0 cells with 0 new cells, skipped 2 cells.
  not replaced 2 cell types:
       1 controller
       1 datapath
Module condcheck: replaced 50 cells with 206 new cells, skipped 40 cells.
  replaced 3 cell types:
      48 $_OR_
       1 $_XOR_
       1 $_MUX_
  not replaced 2 cell types:
      25 $_NOT_
      15 $_AND_
Module condlogic: replaced 0 cells with 0 new cells, skipped 8 cells.
  not replaced 3 cell types:
       5 $_AND_
       1 condcheck
       2 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Module controller: replaced 0 cells with 0 new cells, skipped 2 cells.
  not replaced 2 cell types:
       1 condlogic
       1 decoder
Module cpu_main: replaced 0 cells with 0 new cells, skipped 3 cells.
  not replaced 3 cell types:
       1 arm
       1 imem
       1 dmem
Module datapath: replaced 0 cells with 0 new cells, skipped 11 cells.
  not replaced 7 cell types:
       1 alu
       1 regfile
       1 extend
       3 $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
       2 $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
       2 $paramod\adder\WIDTH=s32'00000000000000000000000000100000
       1 $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Module decoder: replaced 26 cells with 122 new cells, skipped 28 cells.
  replaced 2 cell types:
      20 $_OR_
       6 $_MUX_
  not replaced 2 cell types:
      19 $_NOT_
       9 $_AND_
Module dmem: replaced 32 cells with 224 new cells, skipped 67 cells.
  replaced 1 cell types:
      32 $_MUX_
  not replaced 3 cell types:
       1 $_NOT_
       2 $_AND_
      64 SB_DFFE
Module extend: replaced 21 cells with 108 new cells, skipped 58 cells.
  replaced 2 cell types:
      13 $_OR_
       8 $_MUX_
  not replaced 2 cell types:
       4 $_NOT_
      54 $_AND_
Module imem: replaced 53 cells with 359 new cells, skipped 13 cells.
  replaced 2 cell types:
       4 $_OR_
      49 $_MUX_
  not replaced 2 cell types:
       2 $_NOT_
      11 $_AND_
Module regfile: replaced 966 cells with 6744 new cells, skipped 530 cells.
  replaced 2 cell types:
       6 $_OR_
     960 $_MUX_
  not replaced 3 cell types:
      12 $_NOT_
      38 $_AND_
     480 SB_DFFE

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~11 debug messages>
Extracted 0 AND gates and 130 wires from module `$paramod\adder\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 64 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 32  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 32  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 9889.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     64/     32  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 32  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =   32  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~204 debug messages>
Removed 0 unused cells and 321 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 cells:       32
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~13 debug messages>
Extracted 0 AND gates and 11 wires from module `$paramod\flopenr\WIDTH=s32'00000000000000000000000000000010' to a netlist network with 7 inputs and 2 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 2  bb = 2
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 2  bb = 2
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.00 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      7/      2  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 2  bb = 2
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =    1  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~30 debug messages>
Removed 0 unused cells and 15 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   \SB_DFFER_$abc9_byp cells:        2
ABC RESULTS:           input signals:        6
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~43 debug messages>
Extracted 0 AND gates and 100 wires from module `$paramod\flopr\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 66 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 32  bb = 32
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 32  bb = 32
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.03 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del = 1589.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     66/     32  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 32  bb = 32
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  levB =    1  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~208 debug messages>
Removed 0 unused cells and 194 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:   \SB_DFFR_$abc9_byp cells:       32
ABC RESULTS:           input signals:       35
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 12 AND gates and 39 wires from module `$paramod\mux2\WIDTH=s32'00000000000000000000000000000100' to a netlist network with 9 inputs and 4 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      12  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      24  lev =    2 (2.00)  mem = 0.00 MB  ch =    4  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      24.  Ch =     4.  Total mem =    0.01 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: F:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =       4.0.  Edge =       12.  Cut =       48.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      9/      4  and =      12  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =      4  edge =      12  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 4 : 2=0 0.0 %  3=4 100.0 %  Ave = 3.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~34 debug messages>
Removed 17 unused cells and 30 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:        4
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 96 AND gates and 291 wires from module `$paramod\mux2\WIDTH=s32'00000000000000000000000000100000' to a netlist network with 65 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =      96  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =     192  lev =    2 (2.00)  mem = 0.00 MB  ch =   32  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     192.  Ch =    32.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: P:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: F:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: A:  Del = 1982.00.  Ar =      32.0.  Edge =       96.  Cut =      384.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     65/     32  and =      96  lev =    2 (2.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =     32  edge =      96  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 32 : 2=0 0.0 %  3=32 100.0 %  Ave = 3.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~202 debug messages>
Removed 129 unused cells and 226 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       32
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~11 debug messages>
Extracted 386 AND gates and 1109 wires from module `alu' to a netlist network with 66 inputs and 36 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     386  lev =   10 (1.27)  mem = 0.01 MB  box = 32  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     701  lev =   24 (1.09)  mem = 0.01 MB  ch =   75  box = 32  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     701.  Ch =    73.  Total mem =    0.14 MB. Peak cut mem =    0.02 MB.
ABC: P:  Del = 16703.00.  Ar =     108.0.  Edge =      335.  Cut =     3213.  T =     0.00 sec
ABC: P:  Del = 16703.00.  Ar =     107.0.  Edge =      332.  Cut =     3002.  T =     0.00 sec
ABC: P:  Del = 16703.00.  Ar =     109.0.  Edge =      332.  Cut =     3139.  T =     0.00 sec
ABC: F:  Del = 16703.00.  Ar =     108.0.  Edge =      331.  Cut =     2860.  T =     0.00 sec
ABC: A:  Del = 16703.00.  Ar =     107.0.  Edge =      330.  Cut =     2673.  T =     0.00 sec
ABC: A:  Del = 16703.00.  Ar =     107.0.  Edge =      330.  Cut =     2866.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: The network is not changed by "&mfs".
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     66/     36  and =     383  lev =   13 (1.30)  mem = 0.01 MB  box = 32  bb = 0
ABC: Mapping (K=4)  :  lut =    107  edge =     330  lev =    6 (0.56)  levB =   36  mem = 0.00 MB
ABC: LUT = 107 : 2=33 30.8 %  3=32 29.9 %  4=42 39.3 %  Ave = 3.08
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.03 seconds, total: 0.03 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~216 debug messages>
Removed 630 unused cells and 955 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:      107
ABC RESULTS:   $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 cells:       32
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        2
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 179 wires from module `arm' to a netlist network with 177 inputs and 111 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    177/    111  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~584 debug messages>
Removed 0 unused cells and 288 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        4
ABC RESULTS:          output signals:       12
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 69 AND gates and 256 wires from module `condcheck' to a netlist network with 8 inputs and 1 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      69  lev =   10 (10.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      83  lev =    8 (8.00)  mem = 0.00 MB  ch =    8  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      83.  Ch =     6.  Total mem =    0.01 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      447.  T =     0.00 sec
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      429.  T =     0.00 sec
ABC: P:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      422.  T =     0.00 sec
ABC: F:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      345.  T =     0.00 sec
ABC: A:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      346.  T =     0.00 sec
ABC: A:  Del = 7238.00.  Ar =      22.0.  Edge =       75.  Cut =      346.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =      8/      1  and =      75  lev =    8 (8.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     22  edge =      75  lev =    4 (4.00)  mem = 0.00 MB
ABC: LUT = 22 : 2=6 27.3 %  3=1 4.5 %  4=15 68.2 %  Ave = 3.41
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~26 debug messages>
Removed 100 unused cells and 109 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       22
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 5 AND gates and 27 wires from module `condlogic' to a netlist network with 20 inputs and 9 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     20/      9  and =       5  lev =    1 (0.56)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     20/      9  and =       5  lev =    1 (0.56)  mem = 0.00 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       5.  Ch =     0.  Total mem =    0.00 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: P:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: P:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: F:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: A:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: A:  Del = 1955.00.  Ar =       5.0.  Edge =       10.  Cut =        5.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     20/      9  and =       5  lev =    1 (0.56)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=2)  :  lut =      5  edge =      10  lev =    1 (0.56)  mem = 0.00 MB
ABC: LUT = 5 : 2=5 100.0 %  Ave = 2.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~66 debug messages>
Removed 0 unused cells and 29 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:        5
ABC RESULTS:           input signals:        9
ABC RESULTS:          output signals:        5
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 44 wires from module `controller' to a netlist network with 42 inputs and 16 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     42/     16  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     42/     16  and =       0  lev =    0 (0.00)  mem = 0.00 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.01 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     42/     16  and =       0  lev =    0 (0.00)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~124 debug messages>
Removed 0 unused cells and 58 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        4
ABC RESULTS:          output signals:       12
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 165 wires from module `cpu_main' to a netlist network with 163 inputs and 161 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    163/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    163/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.04 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    163/    161  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~656 debug messages>
Removed 0 unused cells and 324 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        6
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 0 AND gates and 410 wires from module `datapath' to a netlist network with 408 inputs and 332 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  ch =    0  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =       0.  Ch =     0.  Total mem =    0.10 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: P:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: F:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: A:  Del =    0.00.  Ar =       0.0.  Edge =        0.  Cut =        0.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    408/    332  and =       0  lev =    0 (0.00)  mem = 0.01 MB  box = 0  bb = 0
ABC: Mapping (K=0)  :  lut =      0  edge =       0  lev =    0 (0.00)  mem = 0.00 MB
ABC: LUT = 0 : Ave = 0.00
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~1488 debug messages>
Removed 0 unused cells and 740 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:           input signals:       11
ABC RESULTS:          output signals:       13
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 47 AND gates and 172 wires from module `decoder' to a netlist network with 12 inputs and 13 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     12/     13  and =      37  lev =    9 (4.31)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     12/     13  and =      29  lev =    4 (2.54)  mem = 0.00 MB  ch =    2  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      29.  Ch =     2.  Total mem =    0.01 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 3659.00.  Ar =      13.0.  Edge =       42.  Cut =      122.  T =     0.00 sec
ABC: P:  Del = 3659.00.  Ar =      13.0.  Edge =       42.  Cut =      122.  T =     0.00 sec
ABC: P:  Del = 3659.00.  Ar =      13.0.  Edge =       42.  Cut =      126.  T =     0.00 sec
ABC: F:  Del = 3659.00.  Ar =      13.0.  Edge =       42.  Cut =      100.  T =     0.00 sec
ABC: A:  Del = 3659.00.  Ar =      13.0.  Edge =       41.  Cut =      100.  T =     0.00 sec
ABC: A:  Del = 3659.00.  Ar =      13.0.  Edge =       41.  Cut =      100.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     12/     13  and =      48  lev =    4 (2.54)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     13  edge =      41  lev =    2 (1.46)  mem = 0.00 MB
ABC: LUT = 13 : 2=3 23.1 %  3=5 38.5 %  4=5 38.5 %  Ave = 3.15
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~58 debug messages>
Removed 65 unused cells and 87 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       13
ABC RESULTS:           input signals:        3
ABC RESULTS:          output signals:        9
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~69 debug messages>
Extracted 98 AND gates and 359 wires from module `dmem' to a netlist network with 130 inputs and 34 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    130/     34  and =      98  lev =    2 (1.94)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    130/     34  and =     194  lev =    2 (1.94)  mem = 0.01 MB  ch =   32  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     194.  Ch =    32.  Total mem =    0.05 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: P:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: P:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: F:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: A:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: A:  Del = 3346.00.  Ar =      34.0.  Edge =      100.  Cut =      386.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    130/     34  and =      98  lev =    2 (1.94)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=3)  :  lut =     34  edge =     100  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 34 : 2=2 5.9 %  3=32 94.1 %  Ave = 2.94
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~337 debug messages>
Removed 129 unused cells and 293 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       34
ABC RESULTS:           input signals:        6
ABC RESULTS:          output signals:        3
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 91 AND gates and 200 wires from module `extend' to a netlist network with 26 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      91  lev =    5 (3.56)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      66  lev =    3 (2.31)  mem = 0.00 MB  ch =    6  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =      66.  Ch =     6.  Total mem =    0.02 MB. Peak cut mem =    0.00 MB.
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: F:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      26.0.  Edge =       88.  Cut =      210.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     26/     32  and =      76  lev =    3 (2.31)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     26  edge =      88  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 26 : 2=0 0.0 %  3=16 61.5 %  4=10 38.5 %  Ave = 3.38
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~124 debug messages>
Removed 80 unused cells and 132 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       26
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~5 debug messages>
Extracted 162 AND gates and 414 wires from module `imem' to a netlist network with 32 inputs and 32 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =     101  lev =    6 (4.41)  mem = 0.00 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =     111  lev =    5 (3.56)  mem = 0.00 MB  ch =   26  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =     111.  Ch =    24.  Total mem =    0.02 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      726.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      706.  T =     0.00 sec
ABC: P:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      700.  T =     0.00 sec
ABC: F:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      641.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      641.  T =     0.00 sec
ABC: A:  Del = 2035.00.  Ar =      24.0.  Edge =       95.  Cut =      641.  T =     0.00 sec
ABC: Total time =     0.00 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =     32/     32  and =     190  lev =    5 (3.56)  mem = 0.00 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =     24  edge =      95  lev =    1 (1.00)  mem = 0.00 MB
ABC: LUT = 24 : 2=0 0.0 %  3=1 4.2 %  4=23 95.8 %  Ave = 3.96
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.00 seconds, total: 0.00 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~136 debug messages>
Removed 266 unused cells and 322 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:       24
ABC RESULTS:           input signals:        1
ABC RESULTS:          output signals:        1
Removing temp directory.

16.38.16.1. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.2. Executing ABC9_OPS pass (helper functions for ABC9).

16.38.16.3. Executing XAIGER backend.
<suppressed ~485 debug messages>
Extracted 2924 AND gates and 7354 wires from module `regfile' to a netlist network with 558 inputs and 79 outputs.

16.38.16.4. Executing ABC9_EXE pass (technology mapping using ABC9).

16.38.16.5. Executing ABC9.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_lut <abc-temp-dir>/input.lut 
ABC: + read_box <abc-temp-dir>/input.box 
ABC: + &read <abc-temp-dir>/input.xaig 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    2924  lev =   10 (8.67)  mem = 0.04 MB  box = 0  bb = 0
ABC: + &scorr 
ABC: Warning: The network is combinational.
ABC: + &sweep 
ABC: + &dc2 
ABC: + &dch -f 
ABC: + &ps 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    5801  lev =    9 (7.86)  mem = 0.08 MB  ch =  735  box = 0  bb = 0
ABC: + &if -W 750 -v 
ABC: K = 4. Memory (bytes): Truth =    0. Cut =   48. Obj =  128. Set =  528. CutMin = no
ABC: Node =    5801.  Ch =   642.  Total mem =    0.88 MB. Peak cut mem =    0.01 MB.
ABC: P:  Del = 8245.00.  Ar =    1112.0.  Edge =     3921.  Cut =    24374.  T =     0.00 sec
ABC: P:  Del = 8245.00.  Ar =    1049.0.  Edge =     3732.  Cut =    23563.  T =     0.00 sec
ABC: P:  Del = 8245.00.  Ar =     987.0.  Edge =     3407.  Cut =    24910.  T =     0.00 sec
ABC: F:  Del = 8245.00.  Ar =     985.0.  Edge =     3401.  Cut =    20525.  T =     0.00 sec
ABC: A:  Del = 8245.00.  Ar =     985.0.  Edge =     3358.  Cut =    19797.  T =     0.00 sec
ABC: A:  Del = 8245.00.  Ar =     985.0.  Edge =     3358.  Cut =    19728.  T =     0.00 sec
ABC: Total time =     0.01 sec
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + &mfs 
ABC: Timing manager is given but there is no GIA of boxes.
ABC: Error: Abc_FrameUpdateGia(): Tranformation has failed.
ABC: + &ps -l 
ABC: <abc-temp-dir>/input : i/o =    558/     79  and =    2821  lev =    9 (7.86)  mem = 0.04 MB  box = 0  bb = 0
ABC: Mapping (K=4)  :  lut =    985  edge =    3358  lev =    4 (3.62)  mem = 0.03 MB
ABC: LUT = 985 : 2=109 11.1 %  3=364 37.0 %  4=512 52.0 %  Ave = 3.41
ABC: + &write -n <abc-temp-dir>/output.aig 
ABC: + time 
ABC: elapse: 0.11 seconds, total: 0.11 seconds

16.38.16.6. Executing AIGER frontend.
<suppressed ~1283 debug messages>
Removed 4501 unused cells and 5138 unused wires.

16.38.16.7. Executing ABC9_OPS pass (helper functions for ABC9).
ABC RESULTS:              $lut cells:      985
ABC RESULTS:           input signals:       22
ABC RESULTS:          output signals:       17
Removing temp directory.

16.38.17. Executing TECHMAP pass (map to technology primitives).

16.38.17.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_unmap.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/abc9_unmap.v' to AST representation.
Generating RTLIL representation for module `\$__DFF_x__$abc9_flop'.
Generating RTLIL representation for module `\$__ABC9_SCC_BREAKER'.
Successfully finished Verilog frontend.

16.38.17.2. Continuing TECHMAP pass.
Using template $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1 for cells of type $paramod$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110\I3_IS_CI=1'1.
Using template SB_DFFR_$abc9_byp for cells of type SB_DFFR_$abc9_byp.
Using template SB_DFFER_$abc9_byp for cells of type SB_DFFER_$abc9_byp.
No more expansions possible.
<suppressed ~106 debug messages>

16.39. Executing ICE40_WRAPCARRY pass (wrap carries).

16.40. Executing TECHMAP pass (map to technology primitives).

16.40.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

16.40.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~22 debug messages>
Removed 152 unused cells and 12259 unused wires.

16.41. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31

Eliminating LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31

Combining LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)   31
  with \SB_CARRY    (#1)   31
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        4
  3-LUT                4
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       32
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31

Eliminating LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31

Combining LUTs.
Number of LUTs:      139
  2-LUT               33
  3-LUT               64
  4-LUT               42
  with \SB_CARRY    (#0)   32
  with \SB_CARRY    (#1)   31
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       22
  2-LUT                6
  3-LUT                1
  4-LUT               15
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        5
  2-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        5
  2-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        5
  2-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:        0
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       13
  2-LUT                3
  3-LUT                5
  4-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       13
  2-LUT                3
  3-LUT                5
  4-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       13
  2-LUT                3
  3-LUT                5
  4-LUT                5
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       34
  2-LUT                2
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       34
  2-LUT                2
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       34
  2-LUT                2
  3-LUT               32
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       26
  3-LUT               16
  4-LUT               10
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:       24
  3-LUT                1
  4-LUT               23
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:       24
  3-LUT                1
  4-LUT               23
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:       24
  3-LUT                1
  4-LUT               23
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0
Discovering LUTs.
Number of LUTs:      985
  2-LUT              109
  3-LUT              364
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminating LUTs.
Number of LUTs:      985
  2-LUT              109
  3-LUT              364
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Combining LUTs.
Number of LUTs:      985
  2-LUT              109
  3-LUT              364
  4-LUT              512
  with \SB_CARRY    (#0)    0
  with \SB_CARRY    (#1)    0

Eliminated 0 LUTs.
Combined 0 LUTs.
<suppressed ~9753 debug messages>

16.42. Executing TECHMAP pass (map to technology primitives).

16.42.1. Executing Verilog-2005 frontend: /Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/Users/nick/.bin/oss-cad-suite/libexec/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

16.42.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0010 for cells of type $lut.
Using template $paramod$c7754eeb17b54dfe53ea4a973db3714d78ced2f9\$lut for cells of type $lut.
Using template $paramod$58df2c605746858c7e53492c8f57d6f1fafa12d2\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01010100 for cells of type $lut.
Using template $paramod$18455d4fd1270af2266bf4bb1c44971b2eb6b37a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10000000 for cells of type $lut.
Using template $paramod$b28b4ecbaa07efdcc51c93348ccdc2395f8b41c1\$lut for cells of type $lut.
Using template $paramod$efc60783c939ae41b2f3555af407b17c007b27f8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00000001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11011000 for cells of type $lut.
Using template $paramod$e2d96f36ef28053ecd27167cd95b944485ac3146\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0100 for cells of type $lut.
Using template $paramod$e5758a88c2c156ccb3037f71a73d1b15af5b310d\$lut for cells of type $lut.
Using template $paramod$c8f16510db975553c8b0be1064e8f5234175f8a8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11100100 for cells of type $lut.
Using template $paramod$4b9b235bc4444ff899bef0c648e4109b26737f1a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00101010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10100010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00100111 for cells of type $lut.
Using template $paramod$75d5c453cca75cc7a7ca320c4fb7be0932b6aaa7\$lut for cells of type $lut.
Using template $paramod$0ee0167fb5dd83bdfe7197fff23e2c7146c57037\$lut for cells of type $lut.
Using template $paramod$b9305c669fd883d24574655b402c7ff9f28efb1a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00011011 for cells of type $lut.
Using template $paramod$16894c241be5ea1f024e9339dea788b4dbe184ae\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10101000 for cells of type $lut.
Using template $paramod$79364b9974cfc81fb54c164d10340bf9c7bccd7f\$lut for cells of type $lut.
Using template $paramod$3702268f692b8bf258e428f65d3bca4e1f76d98b\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00100000 for cells of type $lut.
Using template $paramod$305fd3b7552c2378a7cd8315d4f432697caa28ea\$lut for cells of type $lut.
Using template $paramod$a2e9ba313c4993e3512c468aa5cd4c9471c6fdce\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11111101 for cells of type $lut.
Using template $paramod$f0182d91674833bec679a7f3f6e4f577d3372e37\$lut for cells of type $lut.
Using template $paramod$b637cf4714c2e93484bb499728e176a6ab69c910\$lut for cells of type $lut.
Using template $paramod$60b5843715a98518c047e515d645503c65e2f462\$lut for cells of type $lut.
Using template $paramod$c8ec3a48216b5155a6ae167a7ceb6c5ef95dcbe2\$lut for cells of type $lut.
Using template $paramod$a201804d96fee71b5e331e11d4287fcf1cc4c095\$lut for cells of type $lut.
Using template $paramod$1b48bc962a0c1e178183f21032378372adc5e26c\$lut for cells of type $lut.
Using template $paramod$e51a8a571bee774247b38f52d6e85fd62ae52cea\$lut for cells of type $lut.
Using template $paramod$253532b742d151c01e8e51f153c24d934b8f6185\$lut for cells of type $lut.
Using template $paramod$382825c351948ba80acaad5e28381320c8b69383\$lut for cells of type $lut.
Using template $paramod$fa67bc369d6bf59edc102e00e9ac9ae5427d9ea0\$lut for cells of type $lut.
Using template $paramod$41a800cf8ab34ffd8bd6b27becdd9b32af451047\$lut for cells of type $lut.
Using template $paramod$5cab357234c9418fe724e6e9eb057a2d3369b33f\$lut for cells of type $lut.
Using template $paramod$6c76e6b411a5e36f2d4de128d17607a6363a98be\$lut for cells of type $lut.
Using template $paramod$3cdf15dbcde0b4495739309d22411cdfea6ec73a\$lut for cells of type $lut.
Using template $paramod$8f5845dc1d0bc1d32f0e551cac16f58157cddba3\$lut for cells of type $lut.
Using template $paramod$34c84a38a1bc6aa36f1daa52808ce6e0746a068c\$lut for cells of type $lut.
Using template $paramod$252bd67535ca340ef5ca0da8c03021b7b5dbcf41\$lut for cells of type $lut.
Using template $paramod$78f11f78437743899e5e31ba57a86be5d1f66665\$lut for cells of type $lut.
Using template $paramod$6d2377d5f977afa491fa1d0f930bab3d96ed905e\$lut for cells of type $lut.
Using template $paramod$92a46abc50e7b478fc93f95b6b2ebe3065f9f141\$lut for cells of type $lut.
Using template $paramod$f58d68d35b693e1ae0436fb6040637a01928c5db\$lut for cells of type $lut.
Using template $paramod$ba0a81bd8407ddb0c2651e89d3c15148e5e529f9\$lut for cells of type $lut.
Using template $paramod$40e5a5bffee68d424d8b966d83c16c547cdeb8ab\$lut for cells of type $lut.
Using template $paramod$ed53936884d8f0c77515f02c43ecf1f4f086a1bf\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11010000 for cells of type $lut.
Using template $paramod$ba7c22fadfbf9ee7abcb895a21403114111dd201\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10000010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10111110 for cells of type $lut.
Using template $paramod$4cf5935e1ab688c7b29c7c684a98523c4a440066\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00001001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11100011 for cells of type $lut.
Using template $paramod$571404c0889eaf57f492cb5e37f8acb5df5852f9\$lut for cells of type $lut.
Using template $paramod$2b29ccbd5fb8b9c557f92ddec1023c75686f32ae\$lut for cells of type $lut.
Using template $paramod$84954618eb9fde76ec37ab04fd2c5afa124986a3\$lut for cells of type $lut.
Using template $paramod$19e5b38cca183d8b6b3a15d20dc995c09cd71893\$lut for cells of type $lut.
Using template $paramod$41326ad8644342a66dfb051d050f2b6fbf15015b\$lut for cells of type $lut.
Using template $paramod$eb3d85023a8c03ed866055b7b6ffb27450652855\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00000100 for cells of type $lut.
Using template $paramod$32abbd1d449a67fb913b4733374e345d4c17175b\$lut for cells of type $lut.
Using template $paramod$01c608da0c772a10858492e8ba4f65bc04f42266\$lut for cells of type $lut.
Using template $paramod$bf60f6ec407ee294958b6566514fc3125ec42258\$lut for cells of type $lut.
Using template $paramod$096a408fd37568b92eea484c5cc9a8e86ab67a87\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0001 for cells of type $lut.
Using template $paramod$fca001e3e0b52158a872e76e56c01ec10dfbb1de\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0110 for cells of type $lut.
Using template $paramod$2ff1ef2fa67138cf71814804285c211c9e377fda\$lut for cells of type $lut.
Using template $paramod$dcba541ad53a9873d71bfba6c13dc2a8e2a60a79\$lut for cells of type $lut.
Using template $paramod$b93d1ea7a612a32c185108f67a153d44ffb9aac2\$lut for cells of type $lut.
Using template $paramod$5e9374f44a27c3f8a1c38af244ec43ceb4fb8d4f\$lut for cells of type $lut.
Using template $paramod$3ccd4e460eeb40194aa88ef0e5239278bde42035\$lut for cells of type $lut.
Using template $paramod$1843b3c15f2447d117e2d5de9b00f791ef5f9fa3\$lut for cells of type $lut.
Using template $paramod$fd904e9e35cfd343a9df248824bd3f1408724879\$lut for cells of type $lut.
Using template $paramod$dcfc23e7d6bcd26b82233688fdfbe92480ddfdcf\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11011100 for cells of type $lut.
Using template $paramod$658b9ed803f0d3d335616d3858b53e0a2522f1e8\$lut for cells of type $lut.
Using template $paramod$6e238df02989b317f10820a22773676e71120644\$lut for cells of type $lut.
Using template $paramod$6d6beead1425af15cf78b27fd9b11b41b5d4bce8\$lut for cells of type $lut.
No more expansions possible.
<suppressed ~2528 debug messages>
Removed 0 unused cells and 3237 unused wires.

16.43. Executing AUTONAME pass.
Renamed 156 objects in module $paramod\adder\WIDTH=s32'00000000000000000000000000100000 (4 iterations).
Renamed 2 objects in module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 (2 iterations).
Renamed 32 objects in module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000 (2 iterations).
Renamed 4 objects in module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100 (2 iterations).
Renamed 32 objects in module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000 (2 iterations).
Renamed 811 objects in module alu (9 iterations).
Renamed 191 objects in module condcheck (15 iterations).
Renamed 5 objects in module condlogic (2 iterations).
Renamed 21 objects in module decoder (4 iterations).
Renamed 104 objects in module dmem (4 iterations).
Renamed 26 objects in module extend (2 iterations).
Renamed 24 objects in module imem (2 iterations).
Renamed 5719 objects in module regfile (13 iterations).
<suppressed ~2467 debug messages>

16.44. Executing HIERARCHY pass (managing design hierarchy).

16.44.1. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \arm
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Used module:         \datapath
Used module:             \alu
Used module:             \extend
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             \regfile
Used module:     \dmem
Used module:     \imem

16.44.2. Analyzing design hierarchy..
Top module:  \cpu_main
Used module:     \arm
Used module:         \controller
Used module:             \condlogic
Used module:                 \condcheck
Used module:                 $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010
Used module:             \decoder
Used module:         \datapath
Used module:             \alu
Used module:             \extend
Used module:             $paramod\adder\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\flopr\WIDTH=s32'00000000000000000000000000100000
Used module:             $paramod\mux2\WIDTH=s32'00000000000000000000000000000100
Used module:             \regfile
Used module:     \dmem
Used module:     \imem
Removed 0 unused modules.

16.45. Printing statistics.

=== $paramod\adder\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                 34
   Number of wire bits:            127
   Number of public wires:          34
   Number of public wire bits:     127
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 63
     SB_CARRY                       31
     SB_LUT4                        32

=== $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010 ===

   Number of wires:                  5
   Number of wire bits:              7
   Number of public wires:           5
   Number of public wire bits:       7
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     SB_DFFER                        2

=== $paramod\flopr\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                  4
   Number of wire bits:             66
   Number of public wires:           4
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 32
     SB_DFFR                        32

=== $paramod\mux2\WIDTH=s32'00000000000000000000000000000100 ===

   Number of wires:                  4
   Number of wire bits:             13
   Number of public wires:           4
   Number of public wire bits:      13
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     SB_LUT4                         4

=== $paramod\mux2\WIDTH=s32'00000000000000000000000000100000 ===

   Number of wires:                  4
   Number of wire bits:             97
   Number of public wires:           4
   Number of public wire bits:      97
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 32
     SB_LUT4                        32

=== alu ===

   Number of wires:                107
   Number of wire bits:            374
   Number of public wires:         107
   Number of public wire bits:     374
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                171
     SB_CARRY                       32
     SB_LUT4                       139

=== arm ===

   Number of wires:                 16
   Number of wire bits:            177
   Number of public wires:          16
   Number of public wire bits:     177
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     controller                      1
     datapath                        1

=== condcheck ===

   Number of wires:                 16
   Number of wire bits:             46
   Number of public wires:          16
   Number of public wire bits:      46
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 22
     SB_LUT4                        22

=== condlogic ===

   Number of wires:                 14
   Number of wire bits:             25
   Number of public wires:          14
   Number of public wire bits:      25
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010      2
     SB_LUT4                         5
     condcheck                       1

=== controller ===

   Number of wires:                 16
   Number of wire bits:             42
   Number of public wires:          16
   Number of public wire bits:      42
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     condlogic                       1
     decoder                         1

=== cpu_main ===

   Number of wires:                  8
   Number of wire bits:            163
   Number of public wires:           8
   Number of public wire bits:     163
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  3
     arm                             1
     dmem                            1
     imem                            1

=== datapath ===

   Number of wires:                 24
   Number of wire bits:            408
   Number of public wires:          24
   Number of public wire bits:     408
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 11
     $paramod\adder\WIDTH=s32'00000000000000000000000000100000      2
     $paramod\flopr\WIDTH=s32'00000000000000000000000000100000      1
     $paramod\mux2\WIDTH=s32'00000000000000000000000000000100      2
     $paramod\mux2\WIDTH=s32'00000000000000000000000000100000      3
     alu                             1
     extend                          1
     regfile                         1

=== decoder ===

   Number of wires:                 17
   Number of wire bits:             46
   Number of public wires:          17
   Number of public wire bits:      46
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 13
     SB_LUT4                        13

=== dmem ===

   Number of wires:                  9
   Number of wire bits:            164
   Number of public wires:           9
   Number of public wire bits:     164
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 98
     SB_DFFE                        64
     SB_LUT4                        34

=== extend ===

   Number of wires:                  3
   Number of wire bits:             58
   Number of public wires:           3
   Number of public wire bits:      58
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 26
     SB_LUT4                        26

=== imem ===

   Number of wires:                  2
   Number of wire bits:             64
   Number of public wires:           2
   Number of public wire bits:      64
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 24
     SB_LUT4                        24

=== regfile ===

   Number of wires:                390
   Number of wire bits:           1949
   Number of public wires:         390
   Number of public wire bits:    1949
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1465
     SB_DFFE                       480
     SB_LUT4                       985

=== design hierarchy ===

   cpu_main                          1
     arm                             1
       controller                    1
         condlogic                   1
           $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010      2
           condcheck                 1
         decoder                     1
       datapath                      1
         $paramod\adder\WIDTH=s32'00000000000000000000000000100000      2
         $paramod\flopr\WIDTH=s32'00000000000000000000000000100000      1
         $paramod\mux2\WIDTH=s32'00000000000000000000000000000100      2
         $paramod\mux2\WIDTH=s32'00000000000000000000000000100000      3
         alu                         1
         extend                      1
         regfile                     1
     dmem                            1
     imem                            1

   Number of wires:                724
   Number of wire bits:           4167
   Number of public wires:         724
   Number of public wire bits:    4167
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               2090
     SB_CARRY                       94
     SB_DFFE                       544
     SB_DFFER                        4
     SB_DFFR                        32
     SB_LUT4                      1416

16.46. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\adder\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\flopenr\WIDTH=s32'00000000000000000000000000000010...
Checking module $paramod\flopr\WIDTH=s32'00000000000000000000000000100000...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000000100...
Checking module $paramod\mux2\WIDTH=s32'00000000000000000000000000100000...
Checking module alu...
Checking module arm...
Checking module condcheck...
Checking module condlogic...
Checking module controller...
Checking module cpu_main...
Checking module datapath...
Checking module decoder...
Checking module dmem...
Checking module extend...
Checking module imem...
Checking module regfile...
Found and reported 0 problems.

End of script. Logfile hash: 0fb4a106ad, CPU: user 1.64s system 0.04s
Yosys 0.19+36 (git sha1 30a4218f5, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 28% 17x abc9_exe (0 sec), 17% 35x read_verilog (0 sec), ...
